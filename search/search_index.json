{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"gitbench","text":"<p>gitbench is a high-performance Git operations library with Python bindings, powered by Rust. It provides efficient repository management, blame analysis, commit extraction, and integration with Git hosting providers.</p>"},{"location":"#key-features","title":"\ud83d\ude80 Key Features","text":"<ul> <li>High-Performance Core: Core operations implemented in Rust for maximum speed</li> <li>Asynchronous API: All repository operations are non-blocking using asyncio</li> <li>Git Provider Integration: Support for GitHub APIs with GitLab and BitBucket coming soon</li> <li>Pydantic Models: Strong validation and serialization for all data</li> <li>Token Management: Automatic token rotation and rate limit handling</li> <li>Pandas Integration: Convert results to DataFrames for analysis</li> </ul>"},{"location":"#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<p>gitbench uses a hybrid architecture:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Python Interface     \u2502   User-friendly API, asyncio integration\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   PyO3 Bridge Layer    \u2502   Seamless Rust-Python interoperability\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Rust Core Library    \u2502   High-performance Git operations\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"#main-components","title":"\ud83d\udccb Main Components","text":""},{"location":"#core-repository-operations","title":"Core Repository Operations","text":"<ul> <li>Repository Manager: Main interface for managing repositories</li> <li>Clone Operations: Non-blocking repository cloning with progress tracking</li> <li>Blame Analysis: Extract and analyze blame information</li> <li>Commit Extraction: Analyze commit history and statistics</li> </ul>"},{"location":"#provider-api-clients","title":"Provider API Clients","text":"<ul> <li>GitHub Client: Complete API client for GitHub</li> <li>Token Manager: Token rotation and rate limit handling</li> <li>Provider Models: Type-safe models for all provider data</li> </ul>"},{"location":"#installation","title":"\ud83d\udd27 Installation","text":"<pre><code>pip install gitbench\n</code></pre> <p>See the Installation Guide for detailed instructions.</p>"},{"location":"#quick-start","title":"\ud83d\udea6 Quick Start","text":"<pre><code>import asyncio\nfrom gitbench import RepoManager\n\nasync def main():\n    # Initialize repository manager\n    repo_manager = RepoManager(\n        urls=[\"https://github.com/user/repo\"],\n        github_username=\"username\",\n        github_token=\"token\"\n    )\n\n    # Clone repositories\n    await repo_manager.clone_all()\n\n    # Get clone tasks\n    tasks = await repo_manager.fetch_clone_tasks()\n\n    # Find a cloned repository\n    repo_path = next(\n        (task.temp_dir for task in tasks.values() \n         if task.status.status_type == \"completed\"),\n        None\n    )\n\n    if repo_path:\n        # Analyze blame\n        blame = await repo_manager.bulk_blame(\n            repo_path, [\"README.md\"]\n        )\n\n        # Extract commits\n        commits = await repo_manager.extract_commits(repo_path)\n\n    # Clean up\n    await repo_manager.cleanup()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>See the Basic Usage Example for a more complete example.</p>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li>Installation: Detailed installation instructions</li> <li>API Reference: Core API documentation</li> <li>Provider APIs: Git provider API clients</li> <li>Examples: Code examples for various use cases</li> <li>Advanced: Performance tips and advanced usage</li> <li>Datetime Handling: Working with dates and times from APIs</li> </ul>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions! See the Contributing Guide for details.</p>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>gitbench is released under the MIT License. See the LICENSE file for details.</p>"},{"location":"CloneStatus/","title":"CloneStatus","text":"<p>In gitbench, there are two types of <code>CloneStatus</code> objects that represent the status of repository cloning operations:</p> <ol> <li>RustCloneStatus: The native Rust implementation returned by <code>RepoManager.fetch_clone_tasks()</code></li> <li>PydanticCloneStatus: A Pydantic model version with additional validation and serialization features</li> </ol> <p>Both types provide the same core functionality but serve different use cases.</p>"},{"location":"CloneStatus/#fields","title":"Fields","text":"<p>Both <code>RustCloneStatus</code> and <code>PydanticCloneStatus</code> share the same fields:</p> <ul> <li><code>status_type</code> (<code>str</code>): The type of status. Possible values are:</li> <li><code>'queued'</code>: The cloning task is waiting to start.</li> <li><code>'cloning'</code>: The repository is currently being cloned. See <code>progress</code> for completion percentage.</li> <li><code>'completed'</code>: The repository has been successfully cloned.</li> <li><code>'failed'</code>: The cloning operation failed. See <code>error</code> for details.</li> <li><code>progress</code> (<code>Optional[int]</code>): The percentage of completion (0-100) if the task is currently cloning, or <code>None</code> otherwise.</li> <li><code>error</code> (<code>Optional[str]</code>): An error message if the cloning operation failed, or <code>None</code> otherwise.</li> </ul>"},{"location":"CloneStatus/#typical-usage","title":"Typical Usage","text":"<p>You will most often encounter <code>CloneStatus</code> as part of a <code>CloneTask</code> when checking the status of repository cloning operations.</p>"},{"location":"CloneStatus/#example-using-rustclonestatus-directly","title":"Example: Using RustCloneStatus Directly","text":"<pre><code>import asyncio\nfrom gitbench import RepoManager\n\nasync def main():\n    urls = [\"https://github.com/owner/repo1.git\"]\n    manager = RepoManager(urls, \"username\", \"token\")\n    await manager.clone_all()\n    clone_tasks = await manager.fetch_clone_tasks()\n    for url, task in clone_tasks.items():\n        status = task.status  # This is a RustCloneStatus object\n        print(f\"Repo: {url}\")\n        print(f\"  Status: {status.status_type}\")\n        if status.status_type == \"cloning\":\n            print(f\"  Progress: {status.progress}%\")\n        if status.status_type == \"failed\":\n            print(f\"  Error: {status.error}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"CloneStatus/#example-converting-to-pydanticclonestatus","title":"Example: Converting to PydanticCloneStatus","text":"<pre><code>import asyncio\nfrom gitbench import RepoManager, to_pydantic_status\n\nasync def main():\n    urls = [\"https://github.com/owner/repo1.git\"]\n    manager = RepoManager(urls, \"username\", \"token\")\n    await manager.clone_all()\n    clone_tasks = await manager.fetch_clone_tasks()\n    for url, task in clone_tasks.items():\n        # Convert RustCloneStatus to PydanticCloneStatus\n        status = to_pydantic_status(task.status)\n        print(f\"Repo: {url}\")\n        print(f\"  Status: {status.status_type}\")\n\n        # Use Pydantic features\n        status_json = status.model_dump_json(indent=2)\n        print(f\"  Status JSON: {status_json}\")\n\nasyncio.run(main())\n</code></pre> <p>The <code>CloneStatus</code> objects help you monitor and react to the state of repository cloning operations in your workflow.</p>"},{"location":"CloneTask/","title":"CloneTask","text":"<p>In gitbench, there are two types of <code>CloneTask</code> objects that represent repository cloning tasks and their statuses:</p> <ol> <li>RustCloneTask: The native Rust implementation returned by <code>RepoManager.fetch_clone_tasks()</code></li> <li>PydanticCloneTask: A Pydantic model version with additional validation and serialization features</li> </ol> <p>Both types provide the same core functionality but serve different use cases.</p>"},{"location":"CloneTask/#rustclonetask-fields","title":"RustCloneTask Fields","text":"<p>The <code>RustCloneTask</code> class represents a repository cloning task directly from the Rust implementation:</p> <ul> <li><code>url</code> (<code>str</code>): The URL of the repository being cloned.</li> <li><code>status</code> (<code>RustCloneStatus</code>): The current status of the cloning operation.</li> <li><code>temp_dir</code> (<code>Optional[str]</code>): The path to the temporary directory where the repository was cloned, or <code>None</code> if cloning has not completed or failed.</li> </ul>"},{"location":"CloneTask/#pydanticclonetask-fields","title":"PydanticCloneTask Fields","text":"<p>The <code>PydanticCloneTask</code> class provides a Pydantic model with the same fields as <code>RustCloneTask</code> but with added validation and serialization:</p> <ul> <li><code>url</code> (<code>str</code>): The URL of the repository being cloned.</li> <li><code>status</code> (<code>PydanticCloneStatus</code>): The current status of the cloning operation as a Pydantic model.</li> <li><code>temp_dir</code> (<code>Optional[str]</code>): The path to the temporary directory where the repository was cloned, or <code>None</code> if cloning has not completed or failed.</li> </ul>"},{"location":"CloneTask/#typical-usage","title":"Typical Usage","text":""},{"location":"CloneTask/#using-rustclonetask-directly","title":"Using RustCloneTask Directly","text":"<pre><code>import asyncio\nfrom gitbench import RepoManager\n\nasync def main():\n    # Create a repo manager\n    urls = [\"https://github.com/owner/repo1.git\"]\n    manager = RepoManager(urls, \"username\", \"token\")\n\n    # Clone repositories\n    await manager.clone_all()\n\n    # Get RustCloneTask objects directly from the manager\n    rust_tasks = await manager.fetch_clone_tasks()\n\n    # Access task information\n    for url, task in rust_tasks.items():\n        print(f\"Repo: {url}\")\n        print(f\"  Status: {task.status.status_type}\")\n        print(f\"  Temp dir: {task.temp_dir}\")\n\n        # Check status type with string comparison\n        if task.status.status_type == \"completed\":\n            print(\"  Cloning completed successfully\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"CloneTask/#converting-to-pydantic-models","title":"Converting to Pydantic Models","text":"<pre><code>import asyncio\nfrom gitbench import RepoManager, convert_clone_tasks\n\nasync def main():\n    # Create a repo manager\n    urls = [\"https://github.com/owner/repo1.git\"]\n    manager = RepoManager(urls, \"username\", \"token\")\n\n    # Clone repositories\n    await manager.clone_all()\n\n    # Get tasks and convert to Pydantic models\n    rust_tasks = await manager.fetch_clone_tasks()\n    pydantic_tasks = convert_clone_tasks(rust_tasks)\n\n    # Use Pydantic features\n    for url, task in pydantic_tasks.items():\n        # Access the same fields\n        print(f\"Repo: {url}\")\n        print(f\"  Status: {task.status.status_type}\")\n\n        # Use Pydantic features\n        task_json = task.model_dump_json(indent=2)\n        print(f\"  JSON: {task_json}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"CloneTask/#using-temp_dir-for-further-operations","title":"Using temp_dir for Further Operations","text":"<p>After cloning, you can use the <code>temp_dir</code> field to perform further operations:</p> <pre><code># ... after fetching clone_tasks ...\nfor url, task in rust_tasks.items():\n    if task.temp_dir:\n        blame = await manager.bulk_blame(task.temp_dir, [\"main.py\"])\n        print(f\"Blame for {url}: {blame}\")\n</code></pre> <p>For details on the <code>status</code> field, see the CloneStatus documentation.</p>"},{"location":"RepoManager/","title":"RepoManager","text":"<p>The <code>RepoManager</code> class is the main interface for managing multiple Git repositories, performing high-performance clone operations, running blame analysis, and extracting commit history. It is designed for asynchronous use, allowing you to efficiently manage and analyze many repositories in parallel.</p> <p>The <code>RepoManager</code> is implemented in Rust for maximum performance, with Python bindings via PyO3.</p> <p>Note: All major methods of <code>RepoManager</code> are asynchronous and should be awaited. You can use Python's <code>asyncio</code> or any compatible event loop to run these methods.</p>"},{"location":"RepoManager/#overview","title":"Overview","text":"<ul> <li>Manage a set of repositories (clone, track status, cleanup)</li> <li>Perform bulk blame operations on files</li> <li>Extract commit history from repositories</li> <li>All operations are designed to be non-blocking and scalable</li> </ul>"},{"location":"RepoManager/#initialization","title":"Initialization","text":"<pre><code>from gitbench import RepoManager\n\n# List of repository URLs to manage\nurls = [\n    \"https://github.com/owner/repo1.git\",\n    \"https://github.com/owner/repo2.git\",\n]\n\n# Create a RepoManager instance\nmanager = RepoManager(urls, github_username=\"your-username\", github_token=\"your-token\")\n</code></pre>"},{"location":"RepoManager/#methods","title":"Methods","text":""},{"location":"RepoManager/#clone_all","title":"clone_all()","text":"<p>Clones all repositories configured in this manager instance asynchronously.</p> <pre><code>await manager.clone_all()\n</code></pre>"},{"location":"RepoManager/#fetch_clone_tasks","title":"fetch_clone_tasks()","text":"<p>Fetches the current status of all cloning tasks asynchronously. Returns a dictionary mapping repository URLs to <code>RustCloneTask</code> objects, which include a <code>RustCloneStatus</code>.</p> <p>Return Type: <code>Dict[str, RustCloneTask]</code></p> <pre><code># Get raw Rust objects\nrust_tasks = await manager.fetch_clone_tasks()\nfor url, task in rust_tasks.items():\n    print(f\"{url}: {task.status.status_type}\")\n\n# Or convert to Pydantic models for additional features\nfrom gitbench import convert_clone_tasks\npydantic_tasks = convert_clone_tasks(rust_tasks)\nfor url, task in pydantic_tasks.items():\n    print(f\"Task: {url}\")\n    print(f\"Status: {task.status.status_type}\")\n    print(f\"JSON: {task.model_dump_json()}\")\n</code></pre>"},{"location":"RepoManager/#cloneurl","title":"clone(url)","text":"<p>Clones a single repository specified by URL asynchronously.</p> <pre><code>await manager.clone(\"https://github.com/owner/repo3.git\")\n</code></pre>"},{"location":"RepoManager/#bulk_blamerepo_path-file_paths","title":"bulk_blame(repo_path, file_paths)","text":"<p>Performs 'git blame' on multiple files within a cloned repository asynchronously. Returns a dictionary mapping file paths to blame results.</p> <pre><code>blame_results = await manager.bulk_blame(\"/path/to/repo\", [\"file1.py\", \"file2.py\"])\nfor file, lines in blame_results.items():\n    print(f\"Blame for {file}:\", lines)\n</code></pre>"},{"location":"RepoManager/#extract_commitsrepo_path","title":"extract_commits(repo_path)","text":"<p>Extracts commit data from a cloned repository asynchronously. Returns a list of commit dictionaries.</p> <pre><code>commits = await manager.extract_commits(\"/path/to/repo\")\nprint(f\"Found {len(commits)} commits.\")\n</code></pre>"},{"location":"RepoManager/#cleanup","title":"cleanup()","text":"<p>Cleans up all temporary directories created for cloned repositories. Returns a dictionary with repository URLs as keys and cleanup results as values (True for success, or an error message).</p> <pre><code>cleanup_results = manager.cleanup()\nfor url, result in cleanup_results.items():\n    print(f\"Cleanup for {url}: {result}\")\n</code></pre>"},{"location":"RepoManager/#simple-example","title":"Simple Example","text":"<pre><code>import asyncio\nfrom gitbench import RepoManager\n\nasync def main():\n    urls = [\"https://github.com/owner/repo1.git\"]\n    manager = RepoManager(urls, github_username=\"username\", github_token=\"token\")\n    await manager.clone_all()\n    tasks = await manager.fetch_clone_tasks()\n    print(tasks)\n    await manager.bulk_blame(\"/path/to/repo\", [\"file1.py\"])\n    await manager.extract_commits(\"/path/to/repo\")\n    manager.cleanup()\n\nasyncio.run(main())\n</code></pre>"},{"location":"RepoManager/#advanced-example-managing-multiple-repositories","title":"Advanced Example: Managing Multiple Repositories","text":"<pre><code>import asyncio\nfrom gitbench import RepoManager\n\nasync def main():\n    urls = [\n        \"https://github.com/owner/repo1.git\",\n        \"https://github.com/owner/repo2.git\",\n        \"https://github.com/owner/repo3.git\",\n    ]\n    manager = RepoManager(urls, github_username=\"username\", github_token=\"token\")\n    await manager.clone_all()\n    clone_tasks = await manager.fetch_clone_tasks()\n    for url, task in clone_tasks.items():\n        print(f\"{url}: {task.status.status_type}\")\n    # Run blame on all files in all repos (example)\n    for url, task in clone_tasks.items():\n        if task.temp_dir:\n            blame = await manager.bulk_blame(task.temp_dir, [\"main.py\", \"utils.py\"])\n            print(f\"Blame for {url}: {blame}\")\n    # Extract commits\n    for url, task in clone_tasks.items():\n        if task.temp_dir:\n            commits = await manager.extract_commits(task.temp_dir)\n            print(f\"Commits for {url}: {len(commits)} found.\")\n    # Cleanup\n    results = manager.cleanup()\n    print(\"Cleanup results:\", results)\n\nasyncio.run(main())\n</code></pre>"},{"location":"RepoManager/#working-with-pydantic-models","title":"Working with Pydantic Models","text":"<p>gitbench provides Pydantic models that mirror the Rust objects returned by <code>RepoManager</code>. These models add serialization, validation, and other Pydantic features:</p> <pre><code>import asyncio\nfrom gitbench import RepoManager\nfrom gitbench import to_pydantic_task, to_pydantic_status, convert_clone_tasks\n\nasync def main():\n    # Create a repo manager\n    manager = RepoManager(urls=[\"https://github.com/owner/repo.git\"], \n                         github_username=\"username\", github_token=\"token\")\n\n    # Get tasks from the manager (returns Rust objects)\n    rust_tasks = await manager.fetch_clone_tasks()\n\n    # Convert individual tasks to Pydantic models\n    for url, task in rust_tasks.items():\n        pydantic_task = to_pydantic_task(task)\n\n        # Now you can use Pydantic features\n        task_json = pydantic_task.model_dump_json(indent=2)\n        print(task_json)\n\n        # Convert a status to Pydantic\n        pydantic_status = to_pydantic_status(task.status)\n        print(pydantic_status.model_dump())\n\n    # Or convert all tasks at once\n    pydantic_tasks = convert_clone_tasks(rust_tasks)\n    print(f\"Converted {len(pydantic_tasks)} tasks to Pydantic models\")\n\nasyncio.run(main())\n</code></pre> <p>For details on the Rust objects <code>RustCloneTask</code> and <code>RustCloneStatus</code>, and their Pydantic counterparts <code>PydanticCloneTask</code> and <code>PydanticCloneStatus</code>, see the CloneTask and CloneStatus documentation pages.</p>"},{"location":"gitbenchAPI/","title":"gitbench Library Public API","text":"<p>This document provides a comprehensive reference for all classes, methods, and functions available to users of the gitbench library.</p>"},{"location":"gitbenchAPI/#repository-management-rust-powered","title":"Repository Management (Rust-powered)","text":""},{"location":"gitbenchAPI/#repomanager","title":"RepoManager","text":"<p>Core class for managing Git repositories.</p> <pre><code>RepoManager(urls: List[str], github_username: str, github_token: str)\n</code></pre> <p>Parameters: - <code>urls</code>: List of repository URLs to clone - <code>github_username</code>: GitHub username for authentication - <code>github_token</code>: GitHub token for authentication</p> <p>Methods:</p>"},{"location":"gitbenchAPI/#clone_all","title":"<code>clone_all()</code>","text":"<p><pre><code>async def clone_all() -&gt; None\n</code></pre> Asynchronously clone all repositories configured in this manager instance.</p>"},{"location":"gitbenchAPI/#fetch_clone_tasks","title":"<code>fetch_clone_tasks()</code>","text":"<p><pre><code>async def fetch_clone_tasks() -&gt; Dict[str, CloneTask]\n</code></pre> Fetches the current status of all cloning tasks asynchronously.</p> <p>Returns: Dictionary mapping repository URLs to <code>CloneTask</code> objects</p>"},{"location":"gitbenchAPI/#clone","title":"<code>clone()</code>","text":"<p><pre><code>async def clone(url: str) -&gt; None\n</code></pre> Clones a single repository specified by URL asynchronously.</p> <p>Parameters: - <code>url</code>: Repository URL to clone</p>"},{"location":"gitbenchAPI/#bulk_blame","title":"<code>bulk_blame()</code>","text":"<p><pre><code>async def bulk_blame(repo_path: str, file_paths: List[str]) -&gt; Dict[str, Any]\n</code></pre> Performs 'git blame' on multiple files within a cloned repository asynchronously.</p> <p>Parameters: - <code>repo_path</code>: Path to local repository - <code>file_paths</code>: List of file paths to blame</p> <p>Returns: Dictionary mapping file paths to blame information</p>"},{"location":"gitbenchAPI/#extract_commits","title":"<code>extract_commits()</code>","text":"<p><pre><code>async def extract_commits(repo_path: str) -&gt; List[Dict[str, Any]]\n</code></pre> Extracts commit data from a cloned repository asynchronously.</p> <p>Parameters: - <code>repo_path</code>: Path to local repository</p> <p>Returns: List of commit dictionaries</p>"},{"location":"gitbenchAPI/#cleanup","title":"<code>cleanup()</code>","text":"<p><pre><code>def cleanup() -&gt; Dict[str, Union[bool, str]]\n</code></pre> Cleans up all temporary directories created for cloned repositories.</p> <p>Returns: Dictionary with repository URLs as keys and cleanup results as values</p>"},{"location":"gitbenchAPI/#clonetask","title":"CloneTask","text":"<p>Represents a repository cloning task.</p> <p>Properties: - <code>url</code>: Repository URL - <code>status</code>: <code>CloneStatus</code> object representing the current status - <code>temp_dir</code>: Temporary directory path where the repository is cloned</p> <p>Methods:</p>"},{"location":"gitbenchAPI/#model_dump","title":"<code>model_dump()</code>","text":"<p><pre><code>def model_dump() -&gt; Dict[str, Any]\n</code></pre> Convert to dictionary.</p>"},{"location":"gitbenchAPI/#model_dump_json","title":"<code>model_dump_json()</code>","text":"<p><pre><code>def model_dump_json(indent: Optional[int] = None) -&gt; str\n</code></pre> Convert to JSON string.</p> <p>Parameters: - <code>indent</code>: Optional indentation level for JSON formatting</p>"},{"location":"gitbenchAPI/#model_validate","title":"<code>model_validate()</code>","text":"<p><pre><code>@classmethod\ndef model_validate(cls, obj: Any) -&gt; CloneTask\n</code></pre> Create from dictionary/object.</p>"},{"location":"gitbenchAPI/#clonestatus","title":"CloneStatus","text":"<p>Represents the status of a cloning operation.</p> <p>Properties: - <code>status_type</code>: Current status type (from <code>CloneStatusType</code> enum) - <code>progress</code>: Percentage progress (0-100) for cloning operations - <code>error</code>: Error message if the cloning failed</p> <p>Methods:</p>"},{"location":"gitbenchAPI/#model_dump_1","title":"<code>model_dump()</code>","text":"<p><pre><code>def model_dump() -&gt; Dict[str, Any]\n</code></pre> Convert to dictionary.</p>"},{"location":"gitbenchAPI/#model_dump_json_1","title":"<code>model_dump_json()</code>","text":"<p><pre><code>def model_dump_json(indent: Optional[int] = None) -&gt; str\n</code></pre> Convert to JSON string.</p> <p>Parameters: - <code>indent</code>: Optional indentation level for JSON formatting</p>"},{"location":"gitbenchAPI/#model_validate_1","title":"<code>model_validate()</code>","text":"<p><pre><code>@classmethod\ndef model_validate(cls, obj: Any) -&gt; CloneStatus\n</code></pre> Create from dictionary/object.</p>"},{"location":"gitbenchAPI/#clonestatustype","title":"CloneStatusType","text":"<p>Enum for clone status:</p> <ul> <li><code>QUEUED</code>: Task is waiting to start</li> <li><code>CLONING</code>: Task is in progress</li> <li><code>COMPLETED</code>: Task completed successfully</li> <li><code>FAILED</code>: Task failed</li> </ul>"},{"location":"gitbenchAPI/#provider-clients","title":"Provider Clients","text":""},{"location":"gitbenchAPI/#githubclient","title":"GitHubClient","text":"<p>Client for GitHub API.</p> <pre><code>GitHubClient(token: str, base_url: Optional[str] = None, \n             token_manager: Optional[TokenManager] = None, \n             use_python_impl: bool = False)\n</code></pre> <p>Parameters: - <code>token</code>: GitHub personal access token - <code>base_url</code>: Optional custom base URL for GitHub Enterprise - <code>token_manager</code>: Optional token manager for rate limit handling - <code>use_python_impl</code>: Force using the Python implementation even if Rust is available</p> <p>Methods:</p>"},{"location":"gitbenchAPI/#fetch_repositories","title":"<code>fetch_repositories()</code>","text":"<p><pre><code>async def fetch_repositories(owner: str) -&gt; List[RepoInfo]\n</code></pre> Get repositories for owner.</p> <p>Parameters: - <code>owner</code>: GitHub username or organization name</p> <p>Returns: List of <code>RepoInfo</code> objects</p>"},{"location":"gitbenchAPI/#fetch_user_info","title":"<code>fetch_user_info()</code>","text":"<p><pre><code>async def fetch_user_info() -&gt; UserInfo\n</code></pre> Get authenticated user info.</p> <p>Returns: <code>UserInfo</code> object representing the authenticated user</p>"},{"location":"gitbenchAPI/#get_rate_limit","title":"<code>get_rate_limit()</code>","text":"<p><pre><code>async def get_rate_limit() -&gt; RateLimitInfo\n</code></pre> Get API rate limit info.</p> <p>Returns: <code>RateLimitInfo</code> object with current limit information</p>"},{"location":"gitbenchAPI/#fetch_repository_details","title":"<code>fetch_repository_details()</code>","text":"<p><pre><code>async def fetch_repository_details(owner: str, repo: str) -&gt; RepoDetails\n</code></pre> Get detailed repository info.</p> <p>Parameters: - <code>owner</code>: Repository owner username or organization - <code>repo</code>: Repository name</p> <p>Returns: <code>RepoDetails</code> object with detailed repository information</p>"},{"location":"gitbenchAPI/#fetch_contributors","title":"<code>fetch_contributors()</code>","text":"<p><pre><code>async def fetch_contributors(owner: str, repo: str) -&gt; List[ContributorInfo]\n</code></pre> Get repository contributors.</p> <p>Parameters: - <code>owner</code>: Repository owner username or organization - <code>repo</code>: Repository name</p> <p>Returns: List of <code>ContributorInfo</code> objects</p>"},{"location":"gitbenchAPI/#fetch_branches","title":"<code>fetch_branches()</code>","text":"<p><pre><code>async def fetch_branches(owner: str, repo: str) -&gt; List[BranchInfo]\n</code></pre> Get repository branches.</p> <p>Parameters: - <code>owner</code>: Repository owner username or organization - <code>repo</code>: Repository name</p> <p>Returns: List of <code>BranchInfo</code> objects</p>"},{"location":"gitbenchAPI/#validate_credentials","title":"<code>validate_credentials()</code>","text":"<p><pre><code>async def validate_credentials() -&gt; bool\n</code></pre> Check if credentials are valid.</p> <p>Returns: Boolean indicating if the credentials are valid</p>"},{"location":"gitbenchAPI/#gitproviderclient","title":"GitProviderClient","text":"<p>Abstract base class for Git provider clients.</p> <pre><code>GitProviderClient(provider_type: ProviderType)\n</code></pre> <p>Parameters: - <code>provider_type</code>: Provider type from <code>ProviderType</code> enum</p> <p>Methods: - Abstract methods implemented by concrete clients (see <code>GitHubClient</code>)</p>"},{"location":"gitbenchAPI/#to_pandas","title":"<code>to_pandas()</code>","text":"<p><pre><code>def to_pandas(data: Union[List[Any], Any]) -&gt; pandas.DataFrame\n</code></pre> Convert data to DataFrame.</p> <p>Parameters: - <code>data</code>: Data to convert (list of objects or single object)</p> <p>Returns: pandas DataFrame</p>"},{"location":"gitbenchAPI/#providertype","title":"ProviderType","text":"<p>Enum for Git provider types:</p> <ul> <li><code>GITHUB</code>: GitHub provider</li> <li><code>GITLAB</code>: GitLab provider</li> <li><code>BITBUCKET</code>: BitBucket provider</li> </ul>"},{"location":"gitbenchAPI/#data-models","title":"Data Models","text":""},{"location":"gitbenchAPI/#userinfo","title":"UserInfo","text":"<p>User information from Git providers.</p> <p>Properties: - <code>id</code>: User ID - <code>login</code>: Username - <code>name</code>: Display name - <code>email</code>: Email address - <code>avatar_url</code>: URL to user avatar - <code>provider_type</code>: Provider type from <code>ProviderType</code> enum - <code>raw_data</code>: Raw API response data</p> <p>Methods:</p>"},{"location":"gitbenchAPI/#model_dump_2","title":"<code>model_dump()</code>","text":"<p><pre><code>def model_dump() -&gt; Dict[str, Any]\n</code></pre> Serialize to dictionary.</p>"},{"location":"gitbenchAPI/#model_dump_json_2","title":"<code>model_dump_json()</code>","text":"<p><pre><code>def model_dump_json(indent: Optional[int] = None) -&gt; str\n</code></pre> Serialize to JSON.</p> <p>Parameters: - <code>indent</code>: Optional indentation level for JSON formatting</p>"},{"location":"gitbenchAPI/#model_validate_2","title":"<code>model_validate()</code>","text":"<p><pre><code>@classmethod\ndef model_validate(cls, obj: Any) -&gt; UserInfo\n</code></pre> Create from dictionary/object.</p>"},{"location":"gitbenchAPI/#repoinfo","title":"RepoInfo","text":"<p>Basic repository information.</p> <p>Properties: - <code>name</code>: Repository name - <code>full_name</code>: Full repository name (owner/name) - <code>clone_url</code>: URL for cloning the repository - <code>description</code>: Repository description - <code>default_branch</code>: Default branch name - <code>created_at</code>: Creation timestamp - <code>updated_at</code>: Last update timestamp - <code>language</code>: Primary language - <code>fork</code>: Whether the repository is a fork - <code>forks_count</code>: Number of forks - <code>stargazers_count</code>: Number of stars - <code>provider_type</code>: Provider type from <code>ProviderType</code> enum - <code>visibility</code>: Repository visibility (public/private) - <code>owner</code>: Repository owner information - <code>raw_data</code>: Raw API response data</p> <p>Methods:</p>"},{"location":"gitbenchAPI/#created_datetime","title":"<code>created_datetime()</code>","text":"<p><pre><code>def created_datetime() -&gt; Optional[datetime]\n</code></pre> Parse <code>created_at</code> as datetime.</p> <p>Returns: Datetime object or None</p>"},{"location":"gitbenchAPI/#updated_datetime","title":"<code>updated_datetime()</code>","text":"<p><pre><code>def updated_datetime() -&gt; Optional[datetime]\n</code></pre> Parse <code>updated_at</code> as datetime.</p> <p>Returns: Datetime object or None</p>"},{"location":"gitbenchAPI/#model_dump_3","title":"<code>model_dump()</code>","text":"<p><pre><code>def model_dump() -&gt; Dict[str, Any]\n</code></pre> Serialize to dictionary.</p>"},{"location":"gitbenchAPI/#model_dump_json_3","title":"<code>model_dump_json()</code>","text":"<p><pre><code>def model_dump_json(indent: Optional[int] = None) -&gt; str\n</code></pre> Serialize to JSON.</p> <p>Parameters: - <code>indent</code>: Optional indentation level for JSON formatting</p>"},{"location":"gitbenchAPI/#model_validate_3","title":"<code>model_validate()</code>","text":"<p><pre><code>@classmethod\ndef model_validate(cls, obj: Any) -&gt; RepoInfo\n</code></pre> Create from dictionary/object.</p>"},{"location":"gitbenchAPI/#repodetails","title":"RepoDetails","text":"<p>Detailed repository information (extends <code>RepoInfo</code>).</p> <p>Additional Properties: - <code>topics</code>: Repository topics/tags - <code>license</code>: Repository license - <code>homepage</code>: Repository homepage URL - <code>has_wiki</code>: Whether the repository has a wiki - <code>has_issues</code>: Whether the repository has issues enabled - <code>has_projects</code>: Whether the repository has projects enabled - <code>archived</code>: Whether the repository is archived - <code>pushed_at</code>: Last push timestamp - <code>size</code>: Repository size in KB</p> <p>Additional Methods:</p>"},{"location":"gitbenchAPI/#pushed_datetime","title":"<code>pushed_datetime()</code>","text":"<p><pre><code>def pushed_datetime() -&gt; Optional[datetime]\n</code></pre> Parse <code>pushed_at</code> as datetime.</p> <p>Returns: Datetime object or None</p>"},{"location":"gitbenchAPI/#ratelimitinfo","title":"RateLimitInfo","text":"<p>API rate limit information.</p> <p>Properties: - <code>limit</code>: Total rate limit - <code>remaining</code>: Remaining API calls - <code>reset_time</code>: Timestamp when the rate limit resets - <code>used</code>: Number of API calls used - <code>provider_type</code>: Provider type from <code>ProviderType</code> enum</p> <p>Methods:</p>"},{"location":"gitbenchAPI/#seconds_until_reset","title":"<code>seconds_until_reset()</code>","text":"<p><pre><code>def seconds_until_reset() -&gt; int\n</code></pre> Get seconds until rate limit resets.</p> <p>Returns: Number of seconds</p>"},{"location":"gitbenchAPI/#model_dump_4","title":"<code>model_dump()</code>","text":"<p><pre><code>def model_dump() -&gt; Dict[str, Any]\n</code></pre> Serialize to dictionary.</p>"},{"location":"gitbenchAPI/#model_dump_json_4","title":"<code>model_dump_json()</code>","text":"<p><pre><code>def model_dump_json(indent: Optional[int] = None) -&gt; str\n</code></pre> Serialize to JSON.</p> <p>Parameters: - <code>indent</code>: Optional indentation level for JSON formatting</p>"},{"location":"gitbenchAPI/#model_validate_4","title":"<code>model_validate()</code>","text":"<p><pre><code>@classmethod\ndef model_validate(cls, obj: Any) -&gt; RateLimitInfo\n</code></pre> Create from dictionary/object.</p>"},{"location":"gitbenchAPI/#branchinfo","title":"BranchInfo","text":"<p>Git branch information.</p> <p>Properties: - <code>name</code>: Branch name - <code>commit_sha</code>: SHA of the branch's HEAD commit - <code>protected</code>: Whether the branch is protected - <code>provider_type</code>: Provider type from <code>ProviderType</code> enum - <code>raw_data</code>: Raw API response data</p> <p>Methods:</p>"},{"location":"gitbenchAPI/#model_dump_5","title":"<code>model_dump()</code>","text":"<p><pre><code>def model_dump() -&gt; Dict[str, Any]\n</code></pre> Serialize to dictionary.</p>"},{"location":"gitbenchAPI/#model_dump_json_5","title":"<code>model_dump_json()</code>","text":"<p><pre><code>def model_dump_json(indent: Optional[int] = None) -&gt; str\n</code></pre> Serialize to JSON.</p> <p>Parameters: - <code>indent</code>: Optional indentation level for JSON formatting</p>"},{"location":"gitbenchAPI/#model_validate_5","title":"<code>model_validate()</code>","text":"<p><pre><code>@classmethod\ndef model_validate(cls, obj: Any) -&gt; BranchInfo\n</code></pre> Create from dictionary/object.</p>"},{"location":"gitbenchAPI/#contributorinfo","title":"ContributorInfo","text":"<p>Repository contributor information.</p> <p>Properties: - <code>id</code>: Contributor ID - <code>login</code>: Contributor username - <code>contributions</code>: Number of contributions - <code>avatar_url</code>: URL to contributor avatar - <code>provider_type</code>: Provider type from <code>ProviderType</code> enum - <code>raw_data</code>: Raw API response data</p> <p>Methods:</p>"},{"location":"gitbenchAPI/#model_dump_6","title":"<code>model_dump()</code>","text":"<p><pre><code>def model_dump() -&gt; Dict[str, Any]\n</code></pre> Serialize to dictionary.</p>"},{"location":"gitbenchAPI/#model_dump_json_6","title":"<code>model_dump_json()</code>","text":"<p><pre><code>def model_dump_json(indent: Optional[int] = None) -&gt; str\n</code></pre> Serialize to JSON.</p> <p>Parameters: - <code>indent</code>: Optional indentation level for JSON formatting</p>"},{"location":"gitbenchAPI/#model_validate_6","title":"<code>model_validate()</code>","text":"<p><pre><code>@classmethod\ndef model_validate(cls, obj: Any) -&gt; ContributorInfo\n</code></pre> Create from dictionary/object.</p>"},{"location":"gitbenchAPI/#token-management","title":"Token Management","text":""},{"location":"gitbenchAPI/#tokenmanager","title":"TokenManager","text":"<p>Manages API tokens and rate limits.</p> <pre><code>TokenManager()\n</code></pre> <p>Methods:</p>"},{"location":"gitbenchAPI/#add_token","title":"<code>add_token()</code>","text":"<p><pre><code>def add_token(token: str, provider_type: ProviderType) -&gt; None\n</code></pre> Add token to the manager.</p> <p>Parameters: - <code>token</code>: API token - <code>provider_type</code>: Provider type from <code>ProviderType</code> enum</p>"},{"location":"gitbenchAPI/#get_next_available_token","title":"<code>get_next_available_token()</code>","text":"<p><pre><code>async def get_next_available_token(provider_type: ProviderType) -&gt; Optional[TokenInfo]\n</code></pre> Get available token for the specified provider.</p> <p>Parameters: - <code>provider_type</code>: Provider type from <code>ProviderType</code> enum</p> <p>Returns: <code>TokenInfo</code> object or None if no tokens are available</p>"},{"location":"gitbenchAPI/#update_rate_limit","title":"<code>update_rate_limit()</code>","text":"<p><pre><code>async def update_rate_limit(token: str, provider_type: ProviderType, \n                           remaining: int, reset_time: int) -&gt; None\n</code></pre> Update rate limit information for a token.</p> <p>Parameters: - <code>token</code>: API token - <code>provider_type</code>: Provider type from <code>ProviderType</code> enum - <code>remaining</code>: Remaining API calls - <code>reset_time</code>: Timestamp when the rate limit resets</p>"},{"location":"gitbenchAPI/#mark_token_invalid","title":"<code>mark_token_invalid()</code>","text":"<p><pre><code>async def mark_token_invalid(token: str, provider_type: ProviderType) -&gt; None\n</code></pre> Mark a token as invalid (e.g., revoked or expired).</p> <p>Parameters: - <code>token</code>: API token - <code>provider_type</code>: Provider type from <code>ProviderType</code> enum</p>"},{"location":"gitbenchAPI/#get_all_tokens","title":"<code>get_all_tokens()</code>","text":"<p><pre><code>def get_all_tokens(provider_type: Optional[ProviderType] = None) -&gt; List[TokenInfo]\n</code></pre> Get all tokens for a provider type or all tokens if no provider specified.</p> <p>Parameters: - <code>provider_type</code>: Optional provider type from <code>ProviderType</code> enum</p> <p>Returns: List of <code>TokenInfo</code> objects</p>"},{"location":"gitbenchAPI/#tokeninfo","title":"TokenInfo","text":"<p>Information about an API token.</p> <p>Properties: - <code>token</code>: Plain text token - <code>provider_type</code>: Provider type from <code>ProviderType</code> enum - <code>status</code>: Current token status - <code>secret_token</code>: Property that returns token as <code>SecretStr</code> for secure handling</p>"},{"location":"gitbenchAPI/#authentication-and-security","title":"Authentication and Security","text":""},{"location":"gitbenchAPI/#credentialmanager","title":"CredentialManager","text":"<p>Manages and securely stores credentials.</p> <pre><code>CredentialManager(encryption_key: Optional[str] = None, use_encryption: bool = True)\n</code></pre> <p>Parameters: - <code>encryption_key</code>: Optional encryption key for securing credentials - <code>use_encryption</code>: Whether to encrypt stored credentials</p> <p>Methods:</p>"},{"location":"gitbenchAPI/#add_credential","title":"<code>add_credential()</code>","text":"<p><pre><code>def add_credential(provider_type: ProviderType, token: str, \n                  username: Optional[str] = None, \n                  email: Optional[str] = None) -&gt; None\n</code></pre> Add a credential to the manager.</p> <p>Parameters: - <code>provider_type</code>: Provider type from <code>ProviderType</code> enum - <code>token</code>: API token - <code>username</code>: Optional username - <code>email</code>: Optional email</p>"},{"location":"gitbenchAPI/#get_credential","title":"<code>get_credential()</code>","text":"<p><pre><code>def get_credential(provider_type: ProviderType) -&gt; Optional[CredentialEntry]\n</code></pre> Get credential for the specified provider.</p> <p>Parameters: - <code>provider_type</code>: Provider type from <code>ProviderType</code> enum</p> <p>Returns: <code>CredentialEntry</code> object or None if not found</p>"},{"location":"gitbenchAPI/#list_credentials","title":"<code>list_credentials()</code>","text":"<p><pre><code>def list_credentials() -&gt; List[CredentialEntry]\n</code></pre> List all stored credentials.</p> <p>Returns: List of <code>CredentialEntry</code> objects</p>"},{"location":"gitbenchAPI/#remove_credential","title":"<code>remove_credential()</code>","text":"<p><pre><code>def remove_credential(provider_type: ProviderType) -&gt; bool\n</code></pre> Remove credential for the specified provider.</p> <p>Parameters: - <code>provider_type</code>: Provider type from <code>ProviderType</code> enum</p> <p>Returns: Boolean indicating if a credential was removed</p>"},{"location":"gitbenchAPI/#save_to_file","title":"<code>save_to_file()</code>","text":"<p><pre><code>def save_to_file(file_path: str) -&gt; None\n</code></pre> Save credentials to a file.</p> <p>Parameters: - <code>file_path</code>: Path to save credentials</p>"},{"location":"gitbenchAPI/#load_from_file","title":"<code>load_from_file()</code>","text":"<p><pre><code>def load_from_file(file_path: str) -&gt; None\n</code></pre> Load credentials from a file.</p> <p>Parameters: - <code>file_path</code>: Path to load credentials from</p>"},{"location":"gitbenchAPI/#clear_all","title":"<code>clear_all()</code>","text":"<p><pre><code>def clear_all() -&gt; None\n</code></pre> Clear all stored credentials.</p>"},{"location":"gitbenchAPI/#utility-functions","title":"Utility Functions","text":""},{"location":"gitbenchAPI/#data-conversion","title":"Data Conversion","text":""},{"location":"gitbenchAPI/#to_dataframe","title":"<code>to_dataframe()</code>","text":"<p><pre><code>def to_dataframe(data: Union[List[Dict[str, Any]], Dict[str, Any], \n                            List[Any], BaseModel, List[BaseModel]]) -&gt; pandas.DataFrame\n</code></pre> Convert various data types to a pandas DataFrame.</p> <p>Parameters: - <code>data</code>: Data to convert (list of objects, dictionary, or Pydantic models)</p> <p>Returns: pandas DataFrame</p>"},{"location":"gitbenchAPI/#flatten_dataframe","title":"<code>flatten_dataframe()</code>","text":"<p><pre><code>def flatten_dataframe(df: pandas.DataFrame, separator: str = \"_\") -&gt; pandas.DataFrame\n</code></pre> Flatten nested DataFrame columns.</p> <p>Parameters: - <code>df</code>: DataFrame to flatten - <code>separator</code>: Separator to use for nested column names</p> <p>Returns: Flattened pandas DataFrame</p>"},{"location":"gitbenchAPI/#to_json","title":"<code>to_json()</code>","text":"<p><pre><code>def to_json(obj: Any, indent: Optional[int] = None) -&gt; str\n</code></pre> Convert object to JSON string.</p> <p>Parameters: - <code>obj</code>: Object to convert - <code>indent</code>: Optional indentation level for JSON formatting</p> <p>Returns: JSON string</p>"},{"location":"gitbenchAPI/#to_dict","title":"<code>to_dict()</code>","text":"<p><pre><code>def to_dict(obj: Any) -&gt; Dict[str, Any]\n</code></pre> Convert object to dictionary.</p> <p>Parameters: - <code>obj</code>: Object to convert</p> <p>Returns: Dictionary representation</p>"},{"location":"gitbenchAPI/#rate-limiting","title":"Rate Limiting","text":""},{"location":"gitbenchAPI/#ratelimiter","title":"<code>RateLimiter</code>","text":"<p>Class for rate limiting API calls.</p> <pre><code>RateLimiter(requests_per_second: float)\n</code></pre> <p>Parameters: - <code>requests_per_second</code>: Maximum requests per second</p> <p>Methods:</p>"},{"location":"gitbenchAPI/#acquire","title":"<code>acquire()</code>","text":"<p><pre><code>async def acquire() -&gt; None\n</code></pre> Acquire a token (blocks if rate exceeded).</p>"},{"location":"gitbenchAPI/#try_acquire","title":"<code>try_acquire()</code>","text":"<p><pre><code>def try_acquire() -&gt; bool\n</code></pre> Try to acquire a token (non-blocking).</p> <p>Returns: Boolean indicating if token was acquired</p>"},{"location":"gitbenchAPI/#rust-type-conversion","title":"Rust Type Conversion","text":""},{"location":"gitbenchAPI/#clone_status_to_pydantic","title":"<code>clone_status_to_pydantic()</code>","text":"<p><pre><code>def clone_status_to_pydantic(rust_status: RustCloneStatus) -&gt; CloneStatus\n</code></pre> Convert Rust <code>CloneStatus</code> to Pydantic model.</p> <p>Parameters: - <code>rust_status</code>: Rust <code>CloneStatus</code> object</p> <p>Returns: Pydantic <code>CloneStatus</code> model</p>"},{"location":"gitbenchAPI/#clone_task_to_pydantic","title":"<code>clone_task_to_pydantic()</code>","text":"<p><pre><code>def clone_task_to_pydantic(rust_task: RustCloneTask) -&gt; CloneTask\n</code></pre> Convert Rust <code>CloneTask</code> to Pydantic model.</p> <p>Parameters: - <code>rust_task</code>: Rust <code>CloneTask</code> object</p> <p>Returns: Pydantic <code>CloneTask</code> model</p>"},{"location":"gitbenchAPI/#package-structure","title":"Package Structure","text":"<p>The library is organized into several subpackages: - <code>gitbench</code> - Main package - <code>gitbench.models</code> - Data models - <code>gitbench.providers</code> - Git provider clients - <code>gitbench.utils</code> - Utility functions and classes</p>"},{"location":"gitbenchAPI/#optional-features","title":"Optional Features","text":"<p>The library has several optional features that can be installed: - <code>pydantic</code> - Enhanced validation and serialization - <code>pandas</code> - Data analysis and DataFrame support - <code>crypto</code> - Secure credential encryption</p> <p>Install with extras like: <code>pip install \"gitbench[pydantic,pandas]\"</code></p>"},{"location":"installation/","title":"Installation Guide","text":"<p>gitbench is a Python package with Rust components that provides Git repository analysis and API clients. This guide covers how to install gitbench and its dependencies.</p>"},{"location":"installation/#basic-installation","title":"Basic Installation","text":"<p>Install gitbench from PyPI:</p> <pre><code>pip install gitbench\n</code></pre> <p>This installs gitbench with minimal dependencies required for core functionality.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python: 3.10 or higher</li> <li>Rust: If you're building from source, you'll need a Rust toolchain (rustc, cargo)</li> </ul>"},{"location":"installation/#installation-options","title":"Installation Options","text":"<p>gitbench follows the optional dependencies pattern, allowing you to install only what you need:</p>"},{"location":"installation/#full-installation-all-features","title":"Full Installation (All Features)","text":"<pre><code>pip install \"gitbench[all]\"\n</code></pre>"},{"location":"installation/#feature-specific-installation","title":"Feature-specific Installation","text":"<p>Choose only the features you need:</p> <pre><code># For data analysis with pandas\npip install \"gitbench[pandas]\"\n\n# For secure token encryption\npip install \"gitbench[crypto]\"\n\n# For pydantic integration (future use)\npip install \"gitbench[pydantic]\"\n\n# For development (linting, testing, etc.)\npip install \"gitbench[dev]\"\n\n# Multiple features can be combined\npip install \"gitbench[pandas,crypto]\"\n</code></pre>"},{"location":"installation/#dependencies-explained","title":"Dependencies Explained","text":""},{"location":"installation/#core-dependencies","title":"Core Dependencies","text":"<ul> <li>httpx: Required for API clients to communicate with Git provider APIs</li> </ul>"},{"location":"installation/#optional-dependencies","title":"Optional Dependencies","text":"<ul> <li>pandas (<code>[pandas]</code>): For data analysis and DataFrame conversion</li> <li>cryptography (<code>[crypto]</code>): For secure token encryption and management</li> <li>pydantic (<code>[pydantic]</code>): For data validation (planned for future use)</li> </ul>"},{"location":"installation/#development-dependencies","title":"Development Dependencies","text":"<ul> <li>maturin: For building the Rust components</li> <li>pytest: For running tests</li> <li>black: For code formatting</li> <li>isort: For import sorting</li> </ul>"},{"location":"installation/#installation-from-source","title":"Installation from Source","text":"<p>Clone the repository and install in development mode:</p> <pre><code># Clone the repository\ngit clone https://github.com/bmeddeb/gitbench.git\ncd gitbench\n\n# Install in development mode with all dependencies\npip install -e \".[all,dev]\"\n\n# Build the Rust components\nmaturin develop\n</code></pre>"},{"location":"installation/#rust-implementation","title":"Rust Implementation","text":"<p>gitbench automatically detects if its Rust components are available and uses them for better performance. If the Rust components aren't available (for example, on platforms without Rust support), gitbench falls back to pure Python implementations.</p>"},{"location":"installation/#platform-support","title":"Platform Support","text":"<p>gitbench is tested on: - Linux (x86_64, aarch64) - macOS (x86_64, Apple Silicon) - Windows (x86_64)</p>"},{"location":"installation/#virtual-environments","title":"Virtual Environments","text":"<p>It's recommended to install gitbench within a virtual environment:</p> <pre><code># Create a virtual environment\npython -m venv venv\n\n# Activate it (Linux/macOS)\nsource venv/bin/activate\n\n# Activate it (Windows)\nvenv\\Scripts\\activate\n\n# Install gitbench\npip install \"gitbench[all]\"\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#rust-build-failures","title":"Rust Build Failures","text":"<p>If you encounter issues building the Rust components:</p> <pre><code># Install required dependencies (Ubuntu/Debian)\napt-get install build-essential libssl-dev pkg-config\n\n# Install with Python-only mode\npip install gitbench\n# Then force Python implementation in your code:\ngithub = GitHubClient(token=\"your-token\", use_python_impl=True)\n</code></pre>"},{"location":"installation/#missing-optional-dependencies","title":"Missing Optional Dependencies","text":"<p>If you see warnings about missing dependencies:</p> <pre><code># Install the required optional dependency\npip install pandas  # For data analysis\npip install cryptography  # For secure token handling\n</code></pre>"},{"location":"installation/#verification","title":"Verification","text":"<p>Verify your installation:</p> <pre><code>import gitbench\n\n# Check version\nprint(gitbench.__version__)  # Should print \"0.2.0\" or newer\n\n# Check if Rust is available (in a script)\nfrom gitbench import GitHubClient\nclient = GitHubClient(token=\"test\")\nprint(f\"Using Rust: {getattr(client, '_use_rust', False)}\")\n</code></pre>"},{"location":"pydantic-integration/","title":"Pydantic Integration","text":"<p>gitbench provides comprehensive integration with Pydantic, offering enhanced validation, serialization, and better type safety for all data models.</p>"},{"location":"pydantic-integration/#overview","title":"Overview","text":"<p>Pydantic integration in gitbench provides the following benefits:</p> <ul> <li>Strong Validation: All API responses are validated against defined schemas</li> <li>Serialization: Easy conversion to JSON, dictionaries, and other formats</li> <li>Type Safety: Improved IDE completions and static type checking</li> <li>Consistent Interface: Same API across Rust and Python components</li> </ul>"},{"location":"pydantic-integration/#data-models","title":"Data Models","text":"<p>All gitbench data models are built using Pydantic's <code>BaseModel</code> class, including:</p> <ul> <li>Provider models (<code>RepoInfo</code>, <code>UserInfo</code>, etc.)</li> <li>Repository management models (<code>CloneStatus</code>, <code>CloneTask</code>)</li> <li>Token and credential management models</li> </ul>"},{"location":"pydantic-integration/#example-usage","title":"Example Usage","text":""},{"location":"pydantic-integration/#basic-model-usage","title":"Basic Model Usage","text":"<pre><code>from gitbench import RepoInfo\n\n# Create a model instance with validation\nrepo = RepoInfo(\n    name=\"example-repo\",\n    full_name=\"user/example-repo\",\n    clone_url=\"https://github.com/user/example-repo.git\",\n    provider_type=\"github\"\n)\n\n# Access properties with proper types\nprint(repo.name)  # example-repo\nprint(repo.fork)  # False (default value)\n\n# Convert to dictionary\nrepo_dict = repo.model_dump()\nprint(repo_dict)\n\n# Convert to JSON with custom formatting\nrepo_json = repo.model_dump_json(indent=2)\nprint(repo_json)\n\n# Parse created_at date if available\nif repo.created_at:\n    dt = repo.created_datetime()\n    if dt:\n        print(f\"Created on: {dt.strftime('%Y-%m-%d')}\")\n</code></pre>"},{"location":"pydantic-integration/#working-with-api-responses","title":"Working with API Responses","text":"<p>When using the GitHubClient, all API responses are automatically converted to Pydantic models:</p> <pre><code>from gitbench import GitHubClient\n\nasync def main():\n    client = GitHubClient(token=\"your-token\")\n\n    # Returns a list of RepoInfo objects\n    repos = await client.fetch_repositories(\"octocat\")\n\n    # Use model methods\n    for repo in repos:\n        print(f\"Repository: {repo.full_name}\")\n        print(f\"Created: {repo.created_datetime()}\")\n\n        # Convert to JSON\n        print(repo.model_dump_json())\n</code></pre>"},{"location":"pydantic-integration/#rust-type-integration","title":"Rust Type Integration","text":"<p>gitbench provides Pydantic wrappers for the Rust-generated classes:</p> <pre><code>from gitbench import RepoManager, CloneTask, CloneStatus, CloneStatusType\n\nasync def main():\n    # Create a RepoManager\n    manager = RepoManager(\n        urls=[\"https://github.com/user/repo.git\"],\n        github_username=\"username\",\n        github_token=\"token\"\n    )\n\n    # Clone repositories\n    await manager.clone_all()\n\n    # Get clone tasks as Pydantic models\n    tasks = await manager.fetch_clone_tasks()\n\n    for url, task in tasks.items():\n        # Access properties with proper type hints\n        print(f\"Repository: {url}\")\n        print(f\"Status: {task.status.status_type}\")\n\n        # Use Pydantic features\n        print(task.model_dump_json(indent=2))\n\n        # Enums for type safety\n        if task.status.status_type == CloneStatusType.COMPLETED:\n            print(f\"Cloned to: {task.temp_dir}\")\n</code></pre>"},{"location":"pydantic-integration/#installation","title":"Installation","text":"<p>To use Pydantic features, install gitbench with the Pydantic extra:</p> <pre><code>pip install \"gitbench[pydantic]\"\n</code></pre> <p>Or install with multiple extras:</p> <pre><code>pip install \"gitbench[pydantic,pandas]\"\n</code></pre>"},{"location":"pydantic-integration/#conversion-utilities","title":"Conversion Utilities","text":"<p>gitbench provides utility functions for working with Pydantic models:</p> <ul> <li><code>to_dict(obj)</code>: Convert any object to a dictionary</li> <li><code>to_json(obj, indent=None)</code>: Convert any object to a JSON string</li> <li><code>to_dataframe(data)</code>: Convert models to a pandas DataFrame</li> <li><code>flatten_dataframe(df)</code>: Flatten nested structures in a DataFrame</li> </ul>"},{"location":"pydantic-integration/#type-stubs","title":"Type Stubs","text":"<p>gitbench includes comprehensive type stubs (<code>.pyi</code> files) for all Pydantic models, ensuring proper IDE completions and static type checking support.</p>"},{"location":"quick-start/","title":"Quick Start Guide","text":"<p>This guide will help you get started with gitbench quickly. We'll cover installation, basic setup, and common operations.</p>"},{"location":"quick-start/#installation","title":"Installation","text":"<p>Install gitbench using pip:</p> <pre><code>pip install gitbench\n</code></pre> <p>For development installations:</p> <pre><code>git clone https://github.com/bmeddeb/gitbench.git\ncd gitbench\npip install -e .\n</code></pre>"},{"location":"quick-start/#basic-usage","title":"Basic Usage","text":""},{"location":"quick-start/#initializing-the-repository-manager","title":"Initializing the Repository Manager","text":"<pre><code>import asyncio\nfrom gitbench import RepoManager\n\n# Replace with your credentials\ngithub_username = \"your-username\"\ngithub_token = \"your-github-token\"\n\n# List of repositories to work with\nrepos = [\n    \"https://github.com/user/repo1\",\n    \"https://github.com/user/repo2\"\n]\n\n# Initialize the repository manager\nrepo_manager = RepoManager(\n    urls=repos,\n    github_username=github_username,\n    github_token=github_token\n)\n</code></pre>"},{"location":"quick-start/#cloning-repositories","title":"Cloning Repositories","text":"<pre><code>async def main():\n    # Clone all repositories asynchronously\n    clone_future = repo_manager.clone_all()\n\n    # Wait for cloning to complete\n    await clone_future\n\n    # Get the status of all clone tasks\n    clone_tasks = await repo_manager.fetch_clone_tasks()\n\n    # Find successfully cloned repositories\n    for url, task in clone_tasks.items():\n        if task.status.status_type == \"completed\":\n            print(f\"Successfully cloned {url} to {task.temp_dir}\")\n        elif task.status.status_type == \"failed\":\n            print(f\"Failed to clone {url}: {task.status.error}\")\n\n# Run the async function\nasyncio.run(main())\n</code></pre>"},{"location":"quick-start/#analyzing-repository-data","title":"Analyzing Repository Data","text":""},{"location":"quick-start/#blame-analysis","title":"Blame Analysis","text":"<pre><code>async def analyze_blame(repo_path, file_paths):\n    # Get blame information for specified files\n    blame_results = await repo_manager.bulk_blame(repo_path, file_paths)\n\n    # Process the results\n    for file_path, blame_info in blame_results.items():\n        if isinstance(blame_info, list):  # Success case\n            print(f\"Blame for {file_path}:\")\n            # Count lines by author\n            authors = {}\n            for line in blame_info:\n                author = line[\"author_name\"]\n                authors[author] = authors.get(author, 0) + 1\n\n            # Show top contributors\n            for author, count in sorted(authors.items(), key=lambda x: x[1], reverse=True):\n                print(f\"  {author}: {count} lines\")\n        else:  # Error case\n            print(f\"Error analyzing {file_path}: {blame_info}\")\n</code></pre>"},{"location":"quick-start/#commit-analysis","title":"Commit Analysis","text":"<pre><code>async def analyze_commits(repo_path):\n    # Extract commit history\n    commits = await repo_manager.extract_commits(repo_path)\n\n    if isinstance(commits, list):  # Success case\n        print(f\"Found {len(commits)} commits\")\n\n        # Show recent commits\n        for commit in commits[:5]:\n            print(f\"Commit: {commit['sha'][:7]}\")\n            print(f\"Author: {commit['author_name']}\")\n            print(f\"Message: {commit['message'].split('\\n')[0]}\")\n            print(f\"Changes: +{commit['additions']} -{commit['deletions']}\")\n    else:  # Error case\n        print(f\"Error analyzing commits: {commits}\")\n</code></pre>"},{"location":"quick-start/#cleaning-up","title":"Cleaning Up","text":"<pre><code>async def cleanup():\n    # Clean up all temporary directories\n    cleanup_results = await repo_manager.cleanup()\n\n    # Check cleanup results\n    for url, result in cleanup_results.items():\n        if result is True:\n            print(f\"Successfully cleaned up {url}\")\n        else:\n            print(f\"Failed to clean up {url}: {result}\")\n</code></pre>"},{"location":"quick-start/#complete-example","title":"Complete Example","text":"<p>Here's a complete example putting everything together:</p> <pre><code>import asyncio\nimport os\nfrom gitbench import RepoManager\n\nasync def main():\n    # Initialize repository manager with credentials from environment\n    repo_manager = RepoManager(\n        urls=[\"https://github.com/bmeddeb/gradelib\"],\n        github_username=os.environ.get(\"GITHUB_USERNAME\"),\n        github_token=os.environ.get(\"GITHUB_TOKEN\")\n    )\n\n    # Clone repositories\n    await repo_manager.clone_all()\n\n    # Get clone statuses\n    clone_tasks = await repo_manager.fetch_clone_tasks()\n\n    # Find a successfully cloned repository\n    repo_path = None\n    for url, task in clone_tasks.items():\n        if task.status.status_type == \"completed\":\n            repo_path = task.temp_dir\n            print(f\"Analyzing repository: {url}\")\n            break\n\n    if repo_path:\n        # Find Python files in the repository\n        file_paths = []\n        for root, _, files in os.walk(repo_path):\n            for file in files:\n                if file.endswith(\".py\"):\n                    rel_path = os.path.join(root, file).replace(repo_path + os.sep, \"\")\n                    file_paths.append(rel_path)\n                    if len(file_paths) &gt;= 3:  # Limit to 3 files\n                        break\n            if len(file_paths) &gt;= 3:\n                break\n\n        # Analyze blame\n        if file_paths:\n            blame_results = await repo_manager.bulk_blame(repo_path, file_paths)\n            for file_path, blame_info in blame_results.items():\n                if isinstance(blame_info, list):\n                    authors = {}\n                    for line in blame_info:\n                        author = line[\"author_name\"]\n                        authors[author] = authors.get(author, 0) + 1\n\n                    print(f\"\\nBlame summary for {file_path}:\")\n                    for author, count in sorted(authors.items(), key=lambda x: x[1], reverse=True):\n                        print(f\"  {author}: {count} lines\")\n\n        # Analyze commits\n        commits = await repo_manager.extract_commits(repo_path)\n        if isinstance(commits, list):\n            print(f\"\\nFound {len(commits)} commits\")\n            print(\"Recent commits:\")\n            for commit in commits[:3]:\n                print(f\"  {commit['sha'][:7]} - {commit['message'].split('\\\\n')[0]}\")\n\n    # Clean up\n    await repo_manager.cleanup()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Repository Manager: More details on repository management</li> <li>Clone Operations: Advanced clone monitoring</li> <li>Provider APIs: Working with Git hosting providers</li> <li>Examples: More complete examples</li> </ul>"},{"location":"token-management/","title":"Token Management","text":"<p>gitbench includes a built-in token management system that helps you handle API rate limits and authentication across multiple tokens. This is especially useful for high-volume applications that need to maximize their API usage.</p>"},{"location":"token-management/#why-token-management","title":"Why Token Management?","text":"<p>Git hosting providers like GitHub, GitLab, and BitBucket implement rate limiting on their APIs to ensure fair usage. When you exceed these limits, your requests will be rejected until the rate limit resets.</p> <p>Using multiple tokens allows you to:</p> <ol> <li>Increase the total number of requests you can make</li> <li>Continue operations when one token hits its rate limit</li> <li>Distribute API load across multiple accounts</li> <li>Maintain availability even when some tokens become invalid</li> </ol>"},{"location":"token-management/#built-in-tokenmanager","title":"Built-in TokenManager","text":"<p>gitbench provides a <code>TokenManager</code> class that automatically handles token rotation, rate limit tracking, and fallback logic:</p> <pre><code>import asyncio\nfrom gitbench import GitHubClient\nfrom gitbench.providers import TokenManager, ProviderType\n\n# Create a token manager\ntoken_manager = TokenManager()\n\n# Add tokens for GitHub\ntoken_manager.add_token(\"your-token-1\", ProviderType.GITHUB)\ntoken_manager.add_token(\"your-token-2\", ProviderType.GITHUB)\ntoken_manager.add_token(\"your-token-3\", ProviderType.GITHUB)\n\n# Create a client with the token manager\ngithub = GitHubClient(\n    token=\"your-token-1\",  # Default token\n    token_manager=token_manager  # Token manager for rotation\n)\n\n# Now use the client as normal - it will automatically rotate tokens as needed\nasync def main():\n    # This will automatically use the next available token if rate limits are hit\n    repos = await github.fetch_repositories(\"octocat\")\n    user = await github.fetch_user_info()\n\n    # Check how many tokens are still available\n    available = token_manager.count_available_tokens(ProviderType.GITHUB)\n    print(f\"{available} GitHub tokens available\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"token-management/#token-status","title":"Token Status","text":"<p>Each token in the manager has a <code>TokenStatus</code> object that tracks its state:</p> <ul> <li>Valid and Available: The token is valid and has API calls remaining</li> <li>Rate Limited: The token has exceeded its rate limit and will become available again after the reset time</li> <li>Invalid: The token is invalid (e.g., revoked, expired)</li> </ul> <p>The token manager automatically: - Tracks rate limits for all tokens - Skips rate-limited tokens until they reset - Marks invalid tokens - Uses the least recently used available token</p>"},{"location":"token-management/#using-multiple-providers","title":"Using Multiple Providers","text":"<p>You can register tokens for different providers:</p> <pre><code>from gitbench.providers import TokenManager, ProviderType\n\n# Create a token manager\ntoken_manager = TokenManager()\n\n# Add tokens for different providers\ntoken_manager.add_token(\"github-token-1\", ProviderType.GITHUB)\ntoken_manager.add_token(\"github-token-2\", ProviderType.GITHUB)\ntoken_manager.add_token(\"gitlab-token-1\", ProviderType.GITLAB)  # (Future)\ntoken_manager.add_token(\"gitlab-token-2\", ProviderType.GITLAB)  # (Future)\n\n# Create provider clients with the same token manager\ngithub = GitHubClient(token=\"github-token-1\", token_manager=token_manager)\n# gitlab = GitLabClient(token=\"gitlab-token-1\", token_manager=token_manager)  # (Future)\n</code></pre>"},{"location":"token-management/#manual-token-management","title":"Manual Token Management","text":"<p>For simple cases, you can also manually handle tokens:</p> <pre><code>import asyncio\nfrom gitbench import GitHubClient\nfrom gitbench.providers.base import RateLimitError\n\n# Initialize clients with different tokens\ngithub1 = GitHubClient(token=\"token1\")\ngithub2 = GitHubClient(token=\"token2\")\n\nasync def fetch_with_fallback(owner):\n    try:\n        # Try with the first token\n        repos = await github1.fetch_repositories(owner)\n        return repos\n    except RateLimitError:\n        # Fallback to the second token\n        repos = await github2.fetch_repositories(owner)\n        return repos\n</code></pre>"},{"location":"token-management/#rate-limit-awareness","title":"Rate Limit Awareness","text":"<p>With the built-in <code>TokenManager</code>, rate limits are tracked automatically. However, you can also manually check rate limits:</p> <pre><code># Check rate limits for a specific client\nrate_limit = await github.get_rate_limit()\nprint(f\"Remaining: {rate_limit.remaining}/{rate_limit.limit}\")\nprint(f\"Reset time: {rate_limit.reset_time}\")\n\n# Check all tokens in a token manager\nfrom gitbench.providers import TokenManager, ProviderType\n\ntoken_manager = TokenManager()\ntoken_manager.add_token(\"token1\", ProviderType.GITHUB)\ntoken_manager.add_token(\"token2\", ProviderType.GITHUB)\n\n# Get all GitHub tokens\ngithub_tokens = token_manager.get_all_tokens(ProviderType.GITHUB)\nfor i, token_info in enumerate(github_tokens):\n    if token_info.rate_limit:\n        print(f\"Token {i+1}: {token_info.rate_limit.remaining}/{token_info.rate_limit.limit}\")\n        print(f\"Status: {token_info.status}\")\n    else:\n        print(f\"Token {i+1}: Rate limit not yet fetched\")\n</code></pre>"},{"location":"token-management/#token-classes","title":"Token Classes","text":""},{"location":"token-management/#tokeninfo","title":"TokenInfo","text":"<p>The <code>TokenInfo</code> class stores information about each token:</p> <pre><code>@dataclass\nclass TokenInfo:\n    token: str                  # The actual token string\n    provider: ProviderType      # Which provider this token is for\n    username: Optional[str]     # Optional username associated with token\n    status: TokenStatus         # Current status information\n\n    # Get a secure version of the token\n    @property\n    def secret_token(self) -&gt; SecretStr:\n        return SecretStr(self.token)\n</code></pre>"},{"location":"token-management/#tokenstatus","title":"TokenStatus","text":"<p>The <code>TokenStatus</code> class tracks the status of a token:</p> <pre><code>@dataclass\nclass TokenStatus:\n    is_valid: bool              # Whether the token is valid\n    remaining_calls: int        # Number of API calls remaining\n    reset_time: Optional[int]   # When rate limit resets (UNIX timestamp)\n    last_used: Optional[float]  # When the token was last used\n\n    # Useful properties\n    @property\n    def is_rate_limited(self) -&gt; bool:\n        \"\"\"Check if the token is currently rate limited.\"\"\"\n        # Returns True if no calls remaining and reset time hasn't passed\n\n    @property\n    def is_available(self) -&gt; bool:\n        \"\"\"Check if the token is available for use.\"\"\"\n        # Returns True if valid and not rate limited\n</code></pre> <p>Example of checking token status:</p> <pre><code># Check token status\nif token_info.status.is_available:\n    print(\"Token is available\")\nelif token_info.status.is_rate_limited:\n    print(f\"Token is rate limited until {time.ctime(token_info.status.reset_time)}\")\nelif not token_info.status.is_valid:\n    print(\"Token is invalid or revoked\")\nprint(f\"Remaining calls: {token_info.status.remaining_calls}\")\n</code></pre>"},{"location":"token-management/#multiple-tokens-example","title":"Multiple Tokens Example","text":"<p>Here's a complete example using the token manager with multiple tokens from environment variables:</p> <pre><code>import os\nimport asyncio\nfrom gitbench import GitHubClient\nfrom gitbench.providers import TokenManager, ProviderType\n\nasync def main():\n    # Get tokens from environment (comma-separated)\n    tokens = os.environ.get(\"GITHUB_TOKENS\", \"\").split(\",\")\n    if not tokens or not tokens[0]:\n        print(\"No tokens found. Set GITHUB_TOKENS environment variable.\")\n        return\n\n    # Create token manager and add tokens\n    token_manager = TokenManager()\n    for token in tokens:\n        token_manager.add_token(token, ProviderType.GITHUB)\n\n    # Create client with token manager\n    github = GitHubClient(\n        token=tokens[0],  # First token as default\n        token_manager=token_manager\n    )\n\n    # Fetch repositories for multiple users\n    users = [\"octocat\", \"torvalds\", \"gvanrossum\", \"kennethreitz\"]\n\n    for user in users:\n        try:\n            repos = await github.fetch_repositories(user)\n            print(f\"Found {len(repos)} repositories for {user}\")\n\n            # The token manager automatically rotated tokens if needed\n        except Exception as e:\n            print(f\"Error fetching repos for {user}: {e}\")\n\n    # Check token statuses after operations\n    print(\"\\nToken statuses:\")\n    for i, token_info in enumerate(token_manager.get_all_tokens(ProviderType.GITHUB)):\n        if token_info.status:\n            if token_info.status.is_rate_limited:\n                status = f\"Rate limited (resets at {time.ctime(token_info.status.reset_time)})\"\n            elif not token_info.status.is_valid:\n                status = \"Invalid\"\n            else:\n                status = f\"Available ({token_info.status.remaining_calls} calls remaining)\"\n        else:\n            status = \"Unknown\"\n\n        print(f\"Token {i+1}: {status}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"token-management/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Store tokens securely: Never hard-code tokens in your source code. Use environment variables or secure secret management.</p> </li> <li> <p>Use the built-in TokenManager: Let gitbench handle token rotation and rate limiting automatically.</p> </li> <li> <p>Handle rate limit errors: Always catch <code>RateLimitError</code> exceptions and implement appropriate fallback logic.</p> </li> <li> <p>Respect API limits: Even with multiple tokens, be respectful of API limits and avoid making unnecessary requests.</p> </li> <li> <p>Implement exponential backoff: When all tokens are rate-limited, implement exponential backoff before retrying.</p> </li> </ol> <pre><code>import asyncio\nimport time\nimport random\nfrom gitbench.providers.base import RateLimitError\n\nasync def fetch_with_backoff(client, owner, max_retries=5):\n    for attempt in range(max_retries):\n        try:\n            return await client.fetch_repositories(owner)\n        except RateLimitError as e:\n            if attempt == max_retries - 1:\n                raise  # Give up after max_retries\n\n            # Calculate wait time with exponential backoff and jitter\n            wait_time = min(2 ** attempt + random.random(), 60)\n            print(f\"Rate limited. Waiting {wait_time:.2f} seconds before retry...\")\n            await asyncio.sleep(wait_time)\n</code></pre>"},{"location":"token-management/#secure-token-storage","title":"Secure Token Storage","text":"<p>For production applications, consider using environment variables or a secure credential store:</p> <pre><code>import os\nfrom gitbench import GitHubClient\nfrom gitbench.providers import TokenManager, ProviderType\n\n# Get tokens from environment variables\ntoken = os.environ.get(\"GITHUB_TOKEN\")\nif not token:\n    raise ValueError(\"GITHUB_TOKEN environment variable not set\")\n\n# Create the client\ngithub = GitHubClient(token=token)\n</code></pre> <p>For more secure storage in Python applications, consider using packages like: - <code>python-dotenv</code> for loading from .env files - <code>keyring</code> for system keychain integration - <code>vault</code> for HashiCorp Vault integration</p>"},{"location":"advanced/datetime-handling/","title":"Working with Dates and Times","text":"<p>gitbench provides helper methods for working with dates and times from Git provider APIs. This guide explains how to use them correctly, especially when performing date arithmetic.</p>"},{"location":"advanced/datetime-handling/#date-fields-in-api-responses","title":"Date Fields in API Responses","text":"<p>Most Git provider APIs return dates and times as ISO 8601 formatted strings:</p> <pre><code>\"created_at\": \"2023-05-10T17:51:29Z\"\n\"updated_at\": \"2023-09-15T12:34:56Z\"\n</code></pre> <p>gitbench models store these as string fields (<code>created_at</code>, <code>updated_at</code>, <code>pushed_at</code>) to preserve the original format. However, helper methods are provided to convert these strings to Python <code>datetime</code> objects when needed.</p>"},{"location":"advanced/datetime-handling/#converting-strings-to-datetime-objects","title":"Converting Strings to Datetime Objects","text":"<p>gitbench provides helper methods to convert date strings to <code>datetime</code> objects:</p> <pre><code># Get repository details\nrepo_details = await github.fetch_repository_details(\"octocat\", \"hello-world\")\n\n# Convert dates to datetime objects\ncreated_dt = repo_details.created_datetime()\nupdated_dt = repo_details.updated_datetime()\n\nif hasattr(repo_details, 'pushed_datetime'):\n    pushed_dt = repo_details.pushed_datetime()\n</code></pre>"},{"location":"advanced/datetime-handling/#important-timezone-awareness","title":"Important: Timezone Awareness","text":"<p>The datetime objects returned by these helper methods are timezone-aware (with UTC timezone). This is important to understand when performing datetime arithmetic.</p> <pre><code># This will print something like: 2023-05-10 17:51:29+00:00\n# Note the +00:00 indicating the UTC timezone\nprint(repo_details.created_datetime())\n</code></pre>"},{"location":"advanced/datetime-handling/#handling-timezone-aware-datetimes","title":"Handling Timezone-Aware Datetimes","text":"<p>When working with these datetime objects, particularly when calculating time differences, you need to be careful about timezone awareness:</p> <pre><code># Get created_datetime (timezone-aware)\ncreated_dt = repo_details.created_datetime()\n\n# INCORRECT: This will raise TypeError because datetime.now() is naive\ntry:\n    days_since = (datetime.now() - created_dt).days  # TypeError!\nexcept TypeError as e:\n    print(f\"Error: {e}\")  # \"can't subtract offset-naive and offset-aware datetimes\"\n</code></pre>"},{"location":"advanced/datetime-handling/#correct-approaches","title":"Correct Approaches","text":""},{"location":"advanced/datetime-handling/#option-1-remove-timezone-information-simplest","title":"Option 1: Remove timezone information (simplest)","text":"<pre><code>from datetime import datetime\n\n# Convert timezone-aware to naive by removing tzinfo\ncreated_dt = repo_details.created_datetime()\nif created_dt:\n    naive_created_dt = created_dt.replace(tzinfo=None)\n    days_since = (datetime.now() - naive_created_dt).days\n    print(f\"Repository created {days_since} days ago\")\n</code></pre>"},{"location":"advanced/datetime-handling/#option-2-make-both-datetimes-timezone-aware","title":"Option 2: Make both datetimes timezone-aware","text":"<pre><code>from datetime import datetime, timezone\n\n# Make both datetimes timezone-aware\ncreated_dt = repo_details.created_datetime()\nif created_dt:\n    now_dt = datetime.now(tz=timezone.utc)\n    days_since = (now_dt - created_dt).days\n    print(f\"Repository created {days_since} days ago\")\n</code></pre>"},{"location":"advanced/datetime-handling/#date-formatting","title":"Date Formatting","text":"<p>You can format datetime objects using standard Python formatting:</p> <pre><code># Format a datetime for display\ncreated_dt = repo_details.created_datetime()\nif created_dt:\n    formatted_date = created_dt.strftime(\"%Y-%m-%d %H:%M:%S\")\n    print(f\"Repository created on: {formatted_date}\")\n</code></pre>"},{"location":"advanced/datetime-handling/#working-with-multiple-date-fields","title":"Working with Multiple Date Fields","text":"<p>Many gitbench models contain multiple date fields:</p> <pre><code># Get all available date information\nif repo.created_at:\n    print(f\"Created: {repo.created_datetime().strftime('%Y-%m-%d')}\")\n\nif repo.updated_at:\n    print(f\"Last updated: {repo.updated_datetime().strftime('%Y-%m-%d')}\")\n\nif hasattr(repo, 'pushed_at') and repo.pushed_at:\n    print(f\"Last pushed: {repo.pushed_datetime().strftime('%Y-%m-%d')}\")\n</code></pre>"},{"location":"advanced/datetime-handling/#rate-limit-reset-times","title":"Rate Limit Reset Times","text":"<p>Rate limit information uses UNIX timestamps for reset times:</p> <pre><code>rate_limit = await github.get_rate_limit()\n\n# Get seconds until reset\nseconds_until_reset = rate_limit.seconds_until_reset()\nprint(f\"Rate limit resets in {seconds_until_reset} seconds\")\n\n# Convert to datetime (if needed)\nfrom datetime import datetime\nreset_datetime = datetime.fromtimestamp(rate_limit.reset_time)\nprint(f\"Rate limit resets at: {reset_datetime.strftime('%Y-%m-%d %H:%M:%S')}\")\n</code></pre>"},{"location":"advanced/performance/","title":"Performance Tips","text":"<p>gitbench is designed with performance in mind, leveraging Rust's speed and memory safety for core Git operations while providing a convenient Python interface. This guide provides tips and best practices for optimizing gitbench's performance in your applications.</p>"},{"location":"advanced/performance/#performance-architecture","title":"Performance Architecture","text":"<p>gitbench's performance architecture is built on several key components:</p> <ol> <li>Rust Implementation for Critical Operations:</li> <li>Repository cloning</li> <li>Git blame analysis</li> <li>Commit history extraction</li> <li> <p>Core repository management</p> </li> <li> <p>Asynchronous Processing:</p> </li> <li>Non-blocking I/O via asyncio and Tokio</li> <li> <p>Parallel operations where appropriate</p> </li> <li> <p>Efficient Memory Management:</p> </li> <li>Streaming results for large repositories</li> <li>Temporary directory cleanup</li> </ol>"},{"location":"advanced/performance/#general-performance-tips","title":"General Performance Tips","text":""},{"location":"advanced/performance/#use-asynchronous-apis","title":"Use Asynchronous APIs","text":"<p>Always prefer asynchronous APIs when available. gitbench's async functions leverage Rust's Tokio runtime for optimal performance:</p> <pre><code># Good: Using async/await\nasync def process_repos():\n    repos = await github_client.fetch_repositories(\"octocat\")\n    return repos\n\n# Bad: Blocking the main thread\ndef process_repos_blocking():\n    # Hypothetical synchronous version would block\n    repos = github_client.fetch_repositories_sync(\"octocat\")\n    return repos\n</code></pre>"},{"location":"advanced/performance/#batch-operations","title":"Batch Operations","text":"<p>Group related operations into batches rather than making multiple individual calls:</p> <pre><code># Good: Batch operation\nresults = await repo_manager.bulk_blame(repo_path, [\"file1.py\", \"file2.py\", \"file3.py\"])\n\n# Less efficient: Individual operations\nresult1 = await repo_manager.blame(repo_path, \"file1.py\")\nresult2 = await repo_manager.blame(repo_path, \"file2.py\")\nresult3 = await repo_manager.blame(repo_path, \"file3.py\")\n</code></pre>"},{"location":"advanced/performance/#process-data-incrementally","title":"Process Data Incrementally","text":"<p>When working with large repositories, process data incrementally rather than loading everything into memory:</p> <pre><code># Process commits in batches\nasync for commit_batch in repo_manager.yield_commits(repo_path, batch_size=100):\n    # Process each batch without loading everything into memory\n    process_batch(commit_batch)\n</code></pre>"},{"location":"advanced/performance/#repository-cloning-performance","title":"Repository Cloning Performance","text":""},{"location":"advanced/performance/#optimize-clone-options","title":"Optimize Clone Options","text":"<p>When cloning repositories, consider using these options for better performance:</p> <pre><code># Clone with minimal history (faster)\nrepo_manager = RepoManager(\n    urls=[\"https://github.com/example/repo.git\"],\n    clone_options={\"depth\": 1}  # Only fetch the latest commit\n)\n</code></pre>"},{"location":"advanced/performance/#efficient-clone-monitoring","title":"Efficient Clone Monitoring","text":"<p>When monitoring clone progress, be mindful of polling frequency:</p> <pre><code># Good: Reasonable refresh rate\nwhile not clone_future.done():\n    clone_tasks = await repo_manager.fetch_clone_tasks()\n    # Process tasks...\n    await asyncio.sleep(1)  # 1 second interval\n\n# Bad: Excessive polling\nwhile not clone_future.done():\n    clone_tasks = await repo_manager.fetch_clone_tasks()\n    # Process tasks...\n    await asyncio.sleep(0.01)  # 10ms interval is too frequent\n</code></pre>"},{"location":"advanced/performance/#clean-up-temporary-directories","title":"Clean Up Temporary Directories","text":"<p>Always clean up temporary directories when you're done with them:</p> <pre><code># Clean up after operations complete\ncleanup_results = repo_manager.cleanup()\n</code></pre>"},{"location":"advanced/performance/#api-interaction-performance","title":"API Interaction Performance","text":""},{"location":"advanced/performance/#rate-limit-management","title":"Rate Limit Management","text":"<p>Efficiently manage rate limits with TokenManager:</p> <pre><code># Create a token manager with multiple tokens\ntoken_manager = TokenManager()\nfor token in github_tokens:\n    token_manager.add_token(token, ProviderType.GITHUB)\n\n# Use token manager for auto-rotation\ngithub = GitHubClient(\n    token=github_tokens[0],  # Default token\n    token_manager=token_manager  # Will rotate tokens as needed\n)\n</code></pre>"},{"location":"advanced/performance/#local-caching","title":"Local Caching","text":"<p>Implement caching for frequently accessed data:</p> <pre><code># Simple in-memory cache\nrepo_cache = {}\n\nasync def get_repo_info(repo_name):\n    if repo_name in repo_cache:\n        return repo_cache[repo_name]\n\n    # Fetch from API\n    repo_info = await github_client.fetch_repository_details(\"owner\", repo_name)\n    repo_cache[repo_name] = repo_info\n    return repo_info\n</code></pre>"},{"location":"advanced/performance/#memory-optimization","title":"Memory Optimization","text":""},{"location":"advanced/performance/#stream-large-repository-data","title":"Stream Large Repository Data","text":"<p>For large repositories, use streaming operations where available:</p> <pre><code># Process large files incrementally\nasync def process_large_file(repo_path, filename):\n    results = []\n    async for blame_batch in repo_manager.stream_blame(repo_path, filename, batch_size=1000):\n        # Process each batch\n        results.extend(analyze_blame(blame_batch))\n    return results\n</code></pre>"},{"location":"advanced/performance/#parallel-processing","title":"Parallel Processing","text":""},{"location":"advanced/performance/#concurrent-api-operations","title":"Concurrent API Operations","text":"<p>Use concurrent operations for independent API tasks:</p> <pre><code>import asyncio\n\nasync def analyze_multiple_repos():\n    # Start multiple operations concurrently\n    tasks = [\n        github_client.fetch_repositories(\"user1\"),\n        github_client.fetch_repositories(\"user2\"),\n        github_client.fetch_repositories(\"user3\"),\n    ]\n\n    # Wait for all to complete\n    results = await asyncio.gather(*tasks)\n    return results\n</code></pre>"},{"location":"advanced/performance/#parallel-git-operations","title":"Parallel Git Operations","text":"<p>For operations on multiple repositories, use concurrent processing:</p> <pre><code>async def analyze_multiple_repos(repo_paths):\n    # Extract commits from multiple repositories concurrently\n    tasks = [\n        repo_manager.extract_commits(repo_path)\n        for repo_path in repo_paths\n    ]\n\n    # Wait for all to complete\n    results = await asyncio.gather(*tasks)\n    return results\n</code></pre>"},{"location":"advanced/performance/#git-operation-performance","title":"Git Operation Performance","text":""},{"location":"advanced/performance/#blame-analysis-optimization","title":"Blame Analysis Optimization","text":"<p>When using blame operations, consider these optimizations:</p> <pre><code># Limit to specific files of interest rather than entire repo\nfile_patterns = [\"*.py\", \"*.rs\", \"*.js\"]\nrelevant_files = []\n\n# Find relevant files (better than recursive search)\nfor pattern in file_patterns:\n    pattern_files = await repo_manager.find_files(repo_path, pattern)\n    relevant_files.extend(pattern_files)\n\n# Then perform blame on the filtered set\nblame_results = await repo_manager.bulk_blame(repo_path, relevant_files)\n</code></pre>"},{"location":"advanced/performance/#commit-extraction-optimization","title":"Commit Extraction Optimization","text":"<p>For commit extraction, filter to reduce processing time:</p> <pre><code># Extract only recent commits (faster)\nrecent_commits = await repo_manager.extract_commits(\n    repo_path, \n    max_count=100,  # Only most recent 100 commits\n    since=\"2023-01-01\"  # Only commits after this date\n)\n</code></pre>"},{"location":"advanced/performance/#monitoring-and-profiling","title":"Monitoring and Profiling","text":""},{"location":"advanced/performance/#memory-usage-monitoring","title":"Memory Usage Monitoring","text":"<p>Monitor memory usage for large operations:</p> <pre><code>import psutil\nimport os\n\ndef log_memory_usage(label):\n    process = psutil.Process(os.getpid())\n    mem = process.memory_info().rss / 1024 / 1024  # Convert to MB\n    print(f\"Memory usage ({label}): {mem:.2f} MB\")\n\nasync def memory_intensive_operation():\n    log_memory_usage(\"Before operation\")\n    result = await repo_manager.extract_commits(repo_path)\n    log_memory_usage(\"After operation\")\n    return result\n</code></pre>"},{"location":"advanced/performance/#performance-timing","title":"Performance Timing","text":"<p>Time critical operations to identify bottlenecks:</p> <pre><code>import time\n\nasync def measure_execution_time(coroutine, *args, **kwargs):\n    start_time = time.time()\n    result = await coroutine(*args, **kwargs)\n    end_time = time.time()\n\n    execution_time = end_time - start_time\n    print(f\"{coroutine.__name__} took {execution_time:.2f} seconds\")\n\n    return result\n\n# Example usage\nresults = await measure_execution_time(\n    repo_manager.bulk_blame, repo_path, file_paths\n)\n</code></pre>"},{"location":"advanced/performance/#implementation-specific-optimizations","title":"Implementation-Specific Optimizations","text":""},{"location":"advanced/performance/#rust-vs-python-implementation","title":"Rust vs Python Implementation","text":"<p>gitbench implements performance-critical operations in Rust, while providing Python implementations for higher-level functionality:</p> <p>Rust-powered operations (leverage these for best performance): - Repository cloning - Git blame analysis - Commit history extraction</p> <p>Python-implemented features: - API clients - Token management - Credential handling - Data conversion utilities</p>"},{"location":"advanced/performance/#when-to-process-locally-vs-via-api","title":"When to Process Locally vs. Via API","text":"<p>For best performance, consider whether to use local Git operations (faster, implemented in Rust) or API operations (more convenient, implemented in Python):</p> <pre><code># Fast local operation using Rust implementation\nblame_info = await repo_manager.bulk_blame(local_repo_path, [\"file.py\"])\n\n# Convenient but potentially slower API operation\nfile_content = await github_client.fetch_file_content(\"owner\", \"repo\", \"file.py\")\n</code></pre>"},{"location":"advanced/performance/#related-topics","title":"Related Topics","text":"<ul> <li>Architecture Overview - Understanding gitbench's performance architecture</li> <li>Python-Rust Bridge - How the Rust and Python components interact</li> </ul>"},{"location":"api/","title":"gitbench Core API Reference","text":"<p>The gitbench Core API provides a set of high-performance operations for Git repositories, implemented in Rust with Python bindings. This page serves as a central reference for the main components of the Core API.</p>"},{"location":"api/#main-components","title":"Main Components","text":""},{"location":"api/#repository-management","title":"Repository Management","text":"<p>The RepoManager class is the central interface for working with Git repositories. It provides methods for:</p> <ul> <li>Cloning repositories</li> <li>Monitoring clone status</li> <li>Extracting blame information</li> <li>Analyzing commit history</li> <li>Managing temporary repositories</li> </ul>"},{"location":"api/#clone-operations","title":"Clone Operations","text":"<p>gitbench provides a robust system for asynchronously cloning repositories and monitoring their status:</p> <ul> <li>CloneStatus: Represents the status of a repository cloning operation</li> <li>CloneTask: Represents a repository cloning task with metadata</li> <li>Clone Monitoring: Advanced techniques for monitoring clone operations</li> </ul>"},{"location":"api/#blame-and-commit-analysis","title":"Blame and Commit Analysis","text":"<p>gitbench excels at high-performance blame and commit analysis:</p> <ul> <li>Blame &amp; Commit Analysis: Extract detailed blame information and commit history</li> </ul>"},{"location":"api/#performance-features","title":"Performance Features","text":"<p>The Core API is designed for high performance:</p> <ul> <li>Rust Implementation: Core operations implemented in Rust for maximum speed</li> <li>Asynchronous Operations: All repository operations are non-blocking using asyncio</li> <li>Parallel Processing: Multiple repositories can be processed concurrently</li> <li>Efficient Memory Usage: Optimized data structures for large repositories</li> </ul>"},{"location":"api/#common-usage-patterns","title":"Common Usage Patterns","text":"<pre><code>import asyncio\nfrom gitbench import RepoManager\n\nasync def main():\n    # Initialize repository manager\n    repo_manager = RepoManager(\n        urls=[\"https://github.com/user/repo\"],\n        github_username=\"your-username\",\n        github_token=\"your-token\"\n    )\n\n    # Clone repositories\n    await repo_manager.clone_all()\n\n    # Get clone tasks\n    clone_tasks = await repo_manager.fetch_clone_tasks()\n\n    # Get a repository path from a successful clone\n    repo_path = next(\n        (task.temp_dir for task in clone_tasks.values() \n         if task.status.status_type == \"completed\"),\n        None\n    )\n\n    if repo_path:\n        # Analyze blame for files\n        file_paths = [\"README.md\", \"src/main.py\"]\n        blame_results = await repo_manager.bulk_blame(repo_path, file_paths)\n\n        # Extract commit history\n        commits = await repo_manager.extract_commits(repo_path)\n\n    # Clean up temporary directories\n    await repo_manager.cleanup()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"api/#error-handling","title":"Error Handling","text":"<p>gitbench provides comprehensive error handling through:</p> <ul> <li>Clear error messages</li> <li>Exception hierarchies</li> <li>Status objects with detailed error information</li> </ul> <p>See the Error Handling guide for more details.</p>"},{"location":"api/#next-steps","title":"Next Steps","text":"<ul> <li>Repository Manager: Detailed documentation for the main RepoManager class</li> <li>CloneStatus and CloneTask: Working with clone operations</li> <li>Complete API Reference: Comprehensive reference for all classes and methods</li> <li>Examples: Practical examples of using the Core API</li> </ul>"},{"location":"api/blame-commit/","title":"Blame and Commit Analysis","text":"<p>gitbench provides powerful tools for analyzing repository blame information and commit history. This page explains how to use these features and interpret the results.</p>"},{"location":"api/blame-commit/#blame-analysis","title":"Blame Analysis","text":"<p>Blame analysis identifies the author and commit information for each line of code in a file. gitbench's blame analysis is implemented in Rust for maximum performance, making it significantly faster than pure Python implementations.</p>"},{"location":"api/blame-commit/#using-the-bulk_blame-method","title":"Using the <code>bulk_blame</code> Method","text":"<p>The <code>bulk_blame</code> method allows you to analyze blame information for multiple files at once:</p> <pre><code>import asyncio\nfrom gitbench import RepoManager\n\nasync def analyze_blame():\n    # Initialize repository manager\n    repo_manager = RepoManager(urls=[\"https://github.com/user/repo\"])\n\n    # Clone the repository\n    await repo_manager.clone_all()\n\n    # Get clone tasks\n    clone_tasks = await repo_manager.fetch_clone_tasks()\n\n    # Find a successfully cloned repository\n    repo_path = None\n    for task in clone_tasks.values():\n        if task.status.status_type == \"completed\":\n            repo_path = task.temp_dir\n            break\n\n    if repo_path:\n        # Specify files to analyze\n        file_paths = [\n            \"README.md\",\n            \"src/main.py\",\n            \"tests/test_main.py\"\n        ]\n\n        # Get blame information\n        blame_results = await repo_manager.bulk_blame(repo_path, file_paths)\n\n        # Process the results\n        for file_path, blame_info in blame_results.items():\n            if isinstance(blame_info, list):  # Success case\n                print(f\"Blame for {file_path}:\")\n\n                # Create a summary by author\n                authors = {}\n                for line in blame_info:\n                    author = line[\"author_name\"]\n                    authors[author] = authors.get(author, 0) + 1\n\n                # Print the summary\n                for author, count in sorted(authors.items(), key=lambda x: x[1], reverse=True):\n                    print(f\"  {author}: {count} lines\")\n            else:  # Error case\n                print(f\"Error analyzing {file_path}: {blame_info}\")\n</code></pre>"},{"location":"api/blame-commit/#blame-result-structure","title":"Blame Result Structure","text":"<p>The <code>bulk_blame</code> method returns a dictionary where: - Keys are file paths - Values are either:   - Lists of line blame information (success case)   - Error messages (error case)</p> <p>For each line in a file, the blame information includes:</p> Field Type Description <code>commit_id</code> string SHA-1 hash of the commit <code>author_name</code> string Name of the author <code>author_email</code> string Email of the author <code>orig_line_no</code> int Original line number in the commit <code>final_line_no</code> int Current line number in the file <code>line_content</code> string Content of the line"},{"location":"api/blame-commit/#advanced-blame-analysis","title":"Advanced Blame Analysis","text":"<p>You can perform more advanced blame analysis by processing the detailed information:</p> <pre><code># Group by commit\ncommits = {}\nfor line in blame_info:\n    commit_id = line[\"commit_id\"]\n    if commit_id not in commits:\n        commits[commit_id] = 0\n    commits[commit_id] += 1\n\n# Find the most significant commits\nsignificant_commits = sorted(commits.items(), key=lambda x: x[1], reverse=True)[:5]\nprint(\"Most significant commits:\")\nfor commit_id, count in significant_commits:\n    print(f\"  {commit_id[:7]}: {count} lines\")\n</code></pre>"},{"location":"api/blame-commit/#commit-analysis","title":"Commit Analysis","text":"<p>Commit analysis extracts detailed information about the commit history of a repository. This includes commit metadata, authorship information, and change statistics.</p>"},{"location":"api/blame-commit/#using-the-extract_commits-method","title":"Using the <code>extract_commits</code> Method","text":"<pre><code>import asyncio\nfrom gitbench import RepoManager\nfrom datetime import datetime\n\nasync def analyze_commits():\n    # Initialize repository manager\n    repo_manager = RepoManager(urls=[\"https://github.com/user/repo\"])\n\n    # Clone the repository\n    await repo_manager.clone_all()\n\n    # Get clone tasks\n    clone_tasks = await repo_manager.fetch_clone_tasks()\n\n    # Find a successfully cloned repository\n    repo_path = None\n    for task in clone_tasks.values():\n        if task.status.status_type == \"completed\":\n            repo_path = task.temp_dir\n            break\n\n    if repo_path:\n        # Extract commit history\n        commits = await repo_manager.extract_commits(repo_path)\n\n        if isinstance(commits, list):  # Success case\n            print(f\"Found {len(commits)} commits\")\n\n            # Show recent commits\n            print(\"\\nRecent commits:\")\n            for commit in commits[:5]:\n                # Convert timestamp to datetime\n                timestamp = commit[\"author_timestamp\"]\n                date = datetime.fromtimestamp(timestamp)\n\n                print(f\"Commit: {commit['sha'][:7]}\")\n                print(f\"Author: {commit['author_name']} &lt;{commit['author_email']}&gt;\")\n                print(f\"Date: {date.strftime('%Y-%m-%d %H:%M:%S')}\")\n                print(f\"Message: {commit['message'].split('\\\\n')[0]}\")\n                print(f\"Changes: +{commit['additions']} -{commit['deletions']}\")\n                print()\n        else:  # Error case\n            print(f\"Error extracting commits: {commits}\")\n</code></pre>"},{"location":"api/blame-commit/#commit-result-structure","title":"Commit Result Structure","text":"<p>The <code>extract_commits</code> method returns either: - A list of commit information objects (success case) - An error message (error case)</p> <p>Each commit information object includes:</p> Field Type Description <code>sha</code> string Full SHA-1 hash of the commit <code>repo_name</code> string Name of the repository <code>message</code> string Full commit message <code>author_name</code> string Name of the author <code>author_email</code> string Email of the author <code>author_timestamp</code> int Author timestamp (Unix epoch) <code>author_offset</code> int Author timezone offset in minutes <code>committer_name</code> string Name of the committer <code>committer_email</code> string Email of the committer <code>committer_timestamp</code> int Committer timestamp (Unix epoch) <code>committer_offset</code> int Committer timezone offset in minutes <code>additions</code> int Number of lines added <code>deletions</code> int Number of lines deleted <code>is_merge</code> bool Whether this is a merge commit"},{"location":"api/blame-commit/#advanced-commit-analysis","title":"Advanced Commit Analysis","text":"<p>You can perform more advanced commit analysis to extract insights:</p> <pre><code># Analyze commit activity over time\nfrom collections import defaultdict\nimport time\n\n# Group commits by month\nmonths = defaultdict(int)\nfor commit in commits:\n    # Get the month from the timestamp\n    date = datetime.fromtimestamp(commit[\"author_timestamp\"])\n    month_key = f\"{date.year}-{date.month:02d}\"\n    months[month_key] += 1\n\n# Print activity by month\nprint(\"Commit activity by month:\")\nfor month, count in sorted(months.items()):\n    print(f\"  {month}: {count} commits\")\n\n# Analyze authors\nauthors = defaultdict(int)\nfor commit in commits:\n    author = commit[\"author_name\"]\n    authors[author] += 1\n\n# Print top contributors\nprint(\"\\nTop contributors:\")\nfor author, count in sorted(authors.items(), key=lambda x: x[1], reverse=True)[:5]:\n    print(f\"  {author}: {count} commits\")\n\n# Analyze code changes\ntotal_additions = sum(commit[\"additions\"] for commit in commits)\ntotal_deletions = sum(commit[\"deletions\"] for commit in commits)\nprint(f\"\\nTotal changes: +{total_additions} -{total_deletions}\")\n</code></pre>"},{"location":"api/blame-commit/#integrating-with-pandas","title":"Integrating with Pandas","text":"<p>gitbench's results can be easily converted to pandas DataFrames for advanced analysis:</p> <pre><code>import pandas as pd\n\n# Convert blame results to DataFrame\ndef blame_to_dataframe(blame_info):\n    return pd.DataFrame(blame_info)\n\n# Convert commit results to DataFrame\ndef commits_to_dataframe(commits):\n    df = pd.DataFrame(commits)\n\n    # Convert timestamps to datetime\n    df[\"author_date\"] = pd.to_datetime(df[\"author_timestamp\"], unit=\"s\")\n    df[\"committer_date\"] = pd.to_datetime(df[\"committer_timestamp\"], unit=\"s\")\n\n    return df\n\n# Usage\nblame_df = blame_to_dataframe(blame_info)\ncommits_df = commits_to_dataframe(commits)\n\n# Example analyses\n# Author contribution by month\nauthor_monthly = commits_df.groupby([\n    commits_df[\"author_date\"].dt.year, \n    commits_df[\"author_date\"].dt.month, \n    \"author_name\"\n])[\"sha\"].count()\n\n# Lines added/removed ratio\ncommits_df[\"change_ratio\"] = commits_df[\"additions\"] / (commits_df[\"deletions\"] + 1)\n</code></pre>"},{"location":"api/blame-commit/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Blame Analysis: For large repositories or files, blame analysis can be resource-intensive. Consider limiting the number of files analyzed at once.</li> <li>Commit Extraction: The <code>extract_commits</code> method retrieves all commits by default. For repositories with very large histories, this can be slow and memory-intensive.</li> <li>Parallelism: The Rust implementation automatically parallelizes operations where possible, but system resources still impact performance.</li> </ul>"},{"location":"api/blame-commit/#related-documentation","title":"Related Documentation","text":"<ul> <li>Repository Manager: Main interface for repository operations</li> <li>Basic Usage Example: Complete example of blame and commit analysis</li> <li>Performance Tips: Tips for maximizing performance</li> </ul>"},{"location":"api/clone-monitoring/","title":"Clone Monitoring","text":"<p>gitbench provides a powerful system for asynchronously cloning Git repositories and monitoring the clone progress. This page explains how to monitor clone operations effectively.</p>"},{"location":"api/clone-monitoring/#overview","title":"Overview","text":"<p>When cloning repositories with gitbench, you can:</p> <ol> <li>Monitor the progress of clone operations in real-time</li> <li>Get detailed status information for each clone task</li> <li>Handle clone failures gracefully</li> <li>Visualize clone progress in various ways</li> </ol>"},{"location":"api/clone-monitoring/#clone-status-types","title":"Clone Status Types","text":"<p>Each clone task can have one of the following status types:</p> Status Type Description <code>queued</code> The clone task is queued but not yet started <code>cloning</code> The clone operation is in progress <code>completed</code> The clone operation completed successfully <code>failed</code> The clone operation failed <p>For <code>cloning</code> status, a progress percentage is also available. For <code>failed</code> status, an error message is provided.</p>"},{"location":"api/clone-monitoring/#basic-clone-monitoring","title":"Basic Clone Monitoring","text":"<p>The simplest way to monitor clone operations is to check the status after cloning:</p> <pre><code>import asyncio\nfrom gitbench import RepoManager\n\nasync def main():\n    # Initialize repository manager\n    repo_manager = RepoManager(\n        urls=[\"https://github.com/user/repo\"],\n        github_username=\"username\",\n        github_token=\"token\"\n    )\n\n    # Start cloning all repositories\n    await repo_manager.clone_all()\n\n    # Get the status of all clone tasks\n    clone_tasks = await repo_manager.fetch_clone_tasks()\n\n    # Check each task's status\n    for url, task in clone_tasks.items():\n        status_type = task.status.status_type\n\n        if status_type == \"completed\":\n            print(f\"\u2705 {url} - Cloned successfully to {task.temp_dir}\")\n        elif status_type == \"failed\":\n            print(f\"\u274c {url} - Failed: {task.status.error}\")\n        else:\n            print(f\"\u23f3 {url} - Status: {status_type}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"api/clone-monitoring/#real-time-progress-monitoring","title":"Real-Time Progress Monitoring","text":"<p>For a better user experience, you can monitor clone progress in real-time:</p> <pre><code>import asyncio\nimport os\nfrom gitbench import RepoManager\n\nasync def main():\n    # Initialize repository manager\n    repo_manager = RepoManager(\n        urls=[\"https://github.com/user/repo1\", \"https://github.com/user/repo2\"],\n        github_username=\"username\",\n        github_token=\"token\"\n    )\n\n    # Start cloning all repositories (returns a future)\n    clone_future = repo_manager.clone_all()\n\n    # Monitor progress until all clones complete\n    try:\n        while not clone_future.done():\n            # Get current status of all clone tasks\n            clone_tasks = await repo_manager.fetch_clone_tasks()\n\n            # Clear terminal (for a cleaner display)\n            os.system('cls' if os.name == 'nt' else 'clear')\n\n            print(\"Repository Clone Status\\n\")\n\n            # Flag to check if all tasks are complete\n            all_done = True\n\n            for url, task in clone_tasks.items():\n                status = task.status.status_type\n                progress = task.status.progress\n\n                # Pretty status indicators\n                status_icon = {\n                    \"queued\": \"\u231b\",\n                    \"cloning\": \"\ud83d\udd04\",\n                    \"completed\": \"\u2705\",\n                    \"failed\": \"\u274c\",\n                }.get(status, \"\u2753\")\n\n                print(f\"{status_icon} {url}\")\n\n                # Show progress bar for cloning status\n                if status == \"cloning\" and progress is not None:\n                    bar_length = 30\n                    filled_length = int(bar_length * progress / 100)\n                    bar = \"\u2588\" * filled_length + \"\u2591\" * (bar_length - filled_length)\n                    print(f\"  Progress: [{bar}] {progress}%\")\n\n                # Show error if failed\n                if status == \"failed\" and task.status.error:\n                    print(f\"  Error: {task.status.error}\")\n\n                # Show clone directory if available\n                if task.temp_dir:\n                    print(f\"  Directory: {task.temp_dir}\")\n\n                print()\n\n                # Check if we need to continue monitoring\n                if status not in [\"completed\", \"failed\"]:\n                    all_done = False\n\n            # Exit the loop if all done\n            if all_done:\n                break\n\n            # Wait before refreshing\n            await asyncio.sleep(1)\n\n        # Make sure the clone_all task completes\n        await clone_future\n\n    except KeyboardInterrupt:\n        print(\"\\nMonitoring interrupted. Clone operations may continue in the background.\")\n\n    print(\"All clone operations completed or failed.\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"api/clone-monitoring/#handling-timeouts-and-cancellation","title":"Handling Timeouts and Cancellation","text":"<p>For long-running clone operations, you may want to implement timeouts:</p> <pre><code>import asyncio\nfrom gitbench import RepoManager\n\nasync def clone_with_timeout(repo_manager, timeout=300):  # 5 minutes timeout\n    # Start cloning\n    clone_future = repo_manager.clone_all()\n\n    try:\n        # Wait for cloning to complete with timeout\n        await asyncio.wait_for(clone_future, timeout=timeout)\n        print(\"All clones completed successfully\")\n    except asyncio.TimeoutError:\n        print(f\"Clone operation timed out after {timeout} seconds\")\n\n        # Check status of timed-out clones\n        clone_tasks = await repo_manager.fetch_clone_tasks()\n\n        for url, task in clone_tasks.items():\n            if task.status.status_type != \"completed\":\n                print(f\"Incomplete: {url} - Status: {task.status.status_type}\")\n\n    # Get final status\n    return await repo_manager.fetch_clone_tasks()\n</code></pre>"},{"location":"api/clone-monitoring/#visualizing-clone-progress-in-a-web-interface","title":"Visualizing Clone Progress in a Web Interface","text":"<p>gitbench can be integrated with web interfaces to provide a better visualization of clone progress. Here's a simple example using Flask:</p> <pre><code>from flask import Flask, jsonify\nimport asyncio\nfrom gitbench import RepoManager\n\napp = Flask(__name__)\n\n# Shared repo manager for the app\nrepo_manager = None\nclone_tasks = {}\n\n@app.route('/start_clone', methods=['POST'])\ndef start_clone():\n    global repo_manager\n\n    # Initialize repo manager with URLs from request\n    repo_manager = RepoManager(\n        urls=[\"https://github.com/user/repo1\", \"https://github.com/user/repo2\"],\n        github_username=\"username\",\n        github_token=\"token\"\n    )\n\n    # Start clone in background task\n    asyncio.create_task(clone_and_monitor())\n\n    return jsonify({\"status\": \"started\"})\n\n@app.route('/status', methods=['GET'])\ndef get_status():\n    # Return current status\n    return jsonify(clone_tasks)\n\nasync def clone_and_monitor():\n    global clone_tasks\n\n    # Start cloning\n    clone_future = repo_manager.clone_all()\n\n    # Monitor until complete\n    while not clone_future.done():\n        # Update status\n        tasks = await repo_manager.fetch_clone_tasks()\n\n        # Convert to serializable format\n        clone_tasks = {}\n        for url, task in tasks.items():\n            clone_tasks[url] = {\n                \"status\": task.status.status_type,\n                \"progress\": task.status.progress,\n                \"error\": task.status.error,\n                \"directory\": task.temp_dir\n            }\n\n        # Wait before checking again\n        await asyncio.sleep(1)\n\n    # One final update\n    tasks = await repo_manager.fetch_clone_tasks()\n\n    # Convert to serializable format\n    clone_tasks = {}\n    for url, task in tasks.items():\n        clone_tasks[url] = {\n            \"status\": task.status.status_type,\n            \"progress\": task.status.progress,\n            \"error\": task.status.error,\n            \"directory\": task.temp_dir\n        }\n\n# Sample HTML/JS client:\n\"\"\"\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Clone Monitor&lt;/title&gt;\n    &lt;script&gt;\n        function updateStatus() {\n            fetch('/status')\n                .then(response =&gt; response.json())\n                .then(data =&gt; {\n                    const statusDiv = document.getElementById('status');\n                    statusDiv.innerHTML = '';\n\n                    for (const [url, task] of Object.entries(data)) {\n                        const taskDiv = document.createElement('div');\n                        taskDiv.className = 'task';\n\n                        // Add task info\n                        taskDiv.innerHTML = `&lt;h3&gt;${url}&lt;/h3&gt;\n                                            &lt;p&gt;Status: ${task.status}&lt;/p&gt;`;\n\n                        // Add progress bar if cloning\n                        if (task.status === 'cloning' &amp;&amp; task.progress !== null) {\n                            taskDiv.innerHTML += `\n                                &lt;div class=\"progress\"&gt;\n                                    &lt;div class=\"progress-bar\" style=\"width: ${task.progress}%\"&gt;\n                                        ${task.progress}%\n                                    &lt;/div&gt;\n                                &lt;/div&gt;`;\n                        }\n\n                        // Add error if failed\n                        if (task.status === 'failed' &amp;&amp; task.error) {\n                            taskDiv.innerHTML += `&lt;p class=\"error\"&gt;Error: ${task.error}&lt;/p&gt;`;\n                        }\n\n                        // Add directory if available\n                        if (task.directory) {\n                            taskDiv.innerHTML += `&lt;p&gt;Directory: ${task.directory}&lt;/p&gt;`;\n                        }\n\n                        statusDiv.appendChild(taskDiv);\n                    }\n                });\n        }\n\n        // Update status every second\n        setInterval(updateStatus, 1000);\n\n        // Initial update\n        document.addEventListener('DOMContentLoaded', updateStatus);\n    &lt;/script&gt;\n    &lt;style&gt;\n        .task {\n            margin: 10px;\n            padding: 15px;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n        }\n        .progress {\n            height: 20px;\n            background-color: #f5f5f5;\n            border-radius: 5px;\n            margin: 10px 0;\n        }\n        .progress-bar {\n            height: 100%;\n            background-color: #4CAF50;\n            text-align: center;\n            line-height: 20px;\n            color: white;\n            border-radius: 5px;\n        }\n        .error {\n            color: red;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Repository Clone Monitor&lt;/h1&gt;\n    &lt;div id=\"status\"&gt;Loading...&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n</code></pre>"},{"location":"api/clone-monitoring/#the-clonestatus-and-clonetask-classes","title":"The <code>CloneStatus</code> and <code>CloneTask</code> Classes","text":"<p>gitbench provides two main classes for tracking clone operations:</p>"},{"location":"api/clone-monitoring/#clonestatus","title":"CloneStatus","text":"<pre><code>class CloneStatus:\n    status_type: str  # \"queued\", \"cloning\", \"completed\", or \"failed\"\n    progress: Optional[int]  # Percentage of completion (0-100) for \"cloning\" status\n    error: Optional[str]  # Error message for \"failed\" status\n</code></pre>"},{"location":"api/clone-monitoring/#clonetask","title":"CloneTask","text":"<pre><code>class CloneTask:\n    url: str  # Repository URL\n    status: CloneStatus  # Current status\n    temp_dir: Optional[str]  # Path to cloned repository (if completed)\n</code></pre>"},{"location":"api/clone-monitoring/#clone-notifications","title":"Clone Notifications","text":"<p>You can implement notifications for clone events:</p> <pre><code>import asyncio\nimport smtplib\nfrom email.message import EmailMessage\nfrom gitbench import RepoManager\n\nasync def clone_with_notifications(repo_manager, email):\n    # Start cloning\n    clone_future = repo_manager.clone_all()\n\n    # Previous status to track changes\n    previous_status = {}\n\n    # Monitor until complete\n    while not clone_future.done():\n        # Get current status\n        clone_tasks = await repo_manager.fetch_clone_tasks()\n\n        # Check for status changes\n        for url, task in clone_tasks.items():\n            current_status = task.status.status_type\n\n            # If we haven't seen this task before or status changed\n            if url not in previous_status or previous_status[url] != current_status:\n                # Update previous status\n                previous_status[url] = current_status\n\n                # Send notification for completed or failed\n                if current_status in [\"completed\", \"failed\"]:\n                    send_notification(\n                        email,\n                        f\"Repository Clone {current_status.capitalize()}\",\n                        f\"The clone of {url} has {current_status}.\\n\" +\n                        (f\"Error: {task.status.error}\" if current_status == \"failed\" else \"\") +\n                        (f\"Directory: {task.temp_dir}\" if task.temp_dir else \"\")\n                    )\n\n        # Wait before checking again\n        await asyncio.sleep(5)\n\ndef send_notification(email, subject, message):\n    # Simple email notification\n    msg = EmailMessage()\n    msg.set_content(message)\n    msg['Subject'] = subject\n    msg['From'] = 'noreply@example.com'\n    msg['To'] = email\n\n    # Send email\n    with smtplib.SMTP('smtp.example.com', 587) as server:\n        server.starttls()\n        server.login('username', 'password')\n        server.send_message(msg)\n</code></pre>"},{"location":"api/clone-monitoring/#related-documentation","title":"Related Documentation","text":"<ul> <li>CloneStatus: Detailed documentation of the CloneStatus class</li> <li>CloneTask: Detailed documentation of the CloneTask class</li> <li>RepoManager: Main interface for repository operations</li> <li>Clone Monitoring Example: Complete example with clone monitoring</li> </ul>"},{"location":"api/error-handling/","title":"Error Handling","text":"<p>gitbench provides a comprehensive error handling system that bridges the gap between Rust's Result-based error handling and Python's exception system. This document explains how errors are handled in gitbench and how to properly handle them in your code.</p>"},{"location":"api/error-handling/#error-propagation-model","title":"Error Propagation Model","text":"<p>gitbench follows a consistent pattern for error propagation:</p> <ol> <li>Rust Core: Uses the Rust <code>Result&lt;T, E&gt;</code> pattern for all operations that can fail</li> <li>Python Bridge: Automatically converts Rust errors into appropriate Python exceptions</li> <li>Python API: Provides error details and contextual information for debugging</li> </ol>"},{"location":"api/error-handling/#common-error-types","title":"Common Error Types","text":"<p>gitbench exposes several error types that you might encounter:</p>"},{"location":"api/error-handling/#gitbencherror","title":"<code>GitBenchError</code>","text":"<p>The base exception class for all gitbench-specific errors.</p> <pre><code>try:\n    result = await repo_manager.clone_all()\nexcept GitBenchError as e:\n    print(f\"gitbench operation failed: {e}\")\n</code></pre>"},{"location":"api/error-handling/#cloneerror","title":"<code>CloneError</code>","text":"<p>Raised when a repository clone operation fails.</p> <pre><code>try:\n    result = await repo_manager.clone_all()\nexcept CloneError as e:\n    print(f\"Clone failed: {e.message}\")\n    print(f\"Repository URL: {e.url}\")\n</code></pre>"},{"location":"api/error-handling/#authenticationerror","title":"<code>AuthenticationError</code>","text":"<p>Raised when authentication fails (e.g., invalid tokens or credentials).</p> <pre><code>try:\n    client = GitHubClient(token=\"invalid_token\")\n    is_valid = await client.validate_credentials()\nexcept AuthenticationError as e:\n    print(f\"Authentication failed: {e}\")\n</code></pre>"},{"location":"api/error-handling/#ratelimiterror","title":"<code>RateLimitError</code>","text":"<p>Raised when API rate limits are exceeded.</p> <pre><code>try:\n    repos = await github_client.fetch_repositories(\"octocat\")\nexcept RateLimitError as e:\n    print(f\"Rate limit exceeded: {e}\")\n    print(f\"Reset time: {e.reset_time}\")\n</code></pre>"},{"location":"api/error-handling/#networkerror","title":"<code>NetworkError</code>","text":"<p>Raised when network operations fail.</p> <pre><code>try:\n    result = await repo_manager.clone_all()\nexcept NetworkError as e:\n    print(f\"Network error: {e}\")\n    print(f\"URL: {e.url}\")\n</code></pre>"},{"location":"api/error-handling/#best-practices-for-error-handling","title":"Best Practices for Error Handling","text":""},{"location":"api/error-handling/#use-specific-exception-types","title":"Use Specific Exception Types","text":"<p>Catch specific exceptions rather than using a broad catch-all:</p> <pre><code>try:\n    # Operation that might fail\n    result = await repo_manager.clone_all()\nexcept CloneError as e:\n    # Handle clone errors\n    print(f\"Clone failed: {e}\")\nexcept AuthenticationError as e:\n    # Handle authentication errors\n    print(f\"Authentication failed: {e}\")\nexcept RateLimitError as e:\n    # Handle rate limit errors\n    print(f\"Rate limit exceeded, reset at: {e.reset_time}\")\nexcept GitBenchError as e:\n    # Handle other gitbench errors\n    print(f\"gitbench operation failed: {e}\")\n</code></pre>"},{"location":"api/error-handling/#async-error-handling","title":"Async Error Handling","text":"<p>Remember that gitbench is primarily async-based, so use the appropriate async error handling patterns:</p> <pre><code>async def safe_operation():\n    try:\n        # Async operation that might fail\n        result = await repo_manager.clone_all()\n        return result\n    except GitBenchError as e:\n        # Log or handle the error\n        print(f\"Error in async operation: {e}\")\n        # Re-raise, handle, or return a fallback\n        raise\n</code></pre>"},{"location":"api/error-handling/#error-recovery","title":"Error Recovery","text":"<p>gitbench provides utility methods for recovery after errors:</p> <pre><code>try:\n    result = await repo_manager.clone_all()\nexcept CloneError as e:\n    # Attempt recovery\n    print(f\"Clone failed, retrying with different settings...\")\n    result = await repo_manager.retry_failed_clones(timeout=300)\n</code></pre>"},{"location":"api/error-handling/#working-with-the-rustpython-boundary","title":"Working with the Rust/Python Boundary","text":"<p>gitbench bridges the Rust and Python error handling systems. Here's what you need to know:</p> <ol> <li>Rust Errors: Rust's <code>Result&lt;T, E&gt;</code> errors are automatically converted to Python exceptions</li> <li>Error Context: Additional context is added during the conversion</li> <li>Custom Errors: You can define custom error types that work on both sides of the boundary</li> </ol> <p>When defining your own extensions or plugins, follow the established error handling patterns:</p> <pre><code>from gitbench import GitBenchError\n\nclass MyCustomError(GitBenchError):\n    \"\"\"Custom error type for my extension.\"\"\"\n    def __init__(self, message, context=None):\n        super().__init__(message)\n        self.context = context\n</code></pre>"},{"location":"api/error-handling/#performance-considerations","title":"Performance Considerations","text":"<p>Error handling in gitbench is designed to be efficient. However, keep these tips in mind:</p> <ol> <li>Avoid Deep Try Blocks: Don't place large, long-running tasks in a single try block</li> <li>Use Error Callbacks: For long-running operations, consider using callbacks instead of exceptions</li> <li>Granular Error Handling: Handle errors at the appropriate level of abstraction</li> </ol>"},{"location":"api/error-handling/#related-topics","title":"Related Topics","text":"<ul> <li>Performance Tips - Optimizing gitbench performance, including error handling</li> <li>Clone Monitoring - Monitoring clone operations, including error states</li> </ul>"},{"location":"development/architecture/","title":"gitbench Architecture","text":"<p>This page provides an overview of gitbench's architecture, explaining the design decisions, component interactions, and implementation details.</p>"},{"location":"development/architecture/#high-level-architecture","title":"High-Level Architecture","text":"<p>gitbench is built with a hybrid architecture that combines the performance of Rust for critical Git operations with the flexibility and ecosystem of Python for API clients and utilities:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                      Python Layer                          \u2502\n\u2502                                                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502 High-level    \u2502   \u2502 Provider APIs  \u2502   \u2502 Utility     \u2502  \u2502\n\u2502  \u2502 Interfaces    \u2502   \u2502 (GitHub, etc.) \u2502   \u2502 Functions   \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2502\n                          \u2502 PyO3\n                          \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                       Rust Layer                           \u2502\n\u2502                                                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502 Clone         \u2502   \u2502 Blame &amp; Commit \u2502   \u2502 Repository  \u2502  \u2502\n\u2502  \u2502 Operations    \u2502   \u2502 Analysis       \u2502   \u2502 Management  \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2502\n                          \u2502 FFI (git2-rs)\n                          \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     External Resources                      \u2502\n\u2502                                                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502 Local Git     \u2502   \u2502 GitHub API     \u2502   \u2502 File System \u2502  \u2502\n\u2502  \u2502 Repositories  \u2502   \u2502                \u2502   \u2502             \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"development/architecture/#core-components","title":"Core Components","text":""},{"location":"development/architecture/#rust-core-performance-critical-operations","title":"Rust Core (Performance-Critical Operations)","text":"<p>The Rust layer implements performance-critical Git operations:</p> <ul> <li>Repository Cloning: Asynchronous cloning with progress tracking</li> <li>Blame Analysis: High-performance blame extraction </li> <li>Commit Extraction: Efficient commit history processing</li> <li>Repository Management: Core repository operations</li> </ul>"},{"location":"development/architecture/#key-rust-modules","title":"Key Rust Modules","text":"<ul> <li><code>src/lib.rs</code>: Main entry point and Python binding definitions</li> <li><code>src/repo.rs</code>: Repository management logic</li> <li><code>src/blame.rs</code>: Git blame implementation</li> <li><code>src/commits.rs</code>: Commit history extraction</li> <li><code>src/clone.rs</code>: Repository cloning with progress tracking</li> </ul>"},{"location":"development/architecture/#python-layer-api-clients-utilities","title":"Python Layer (API Clients &amp; Utilities)","text":"<p>The Python layer provides high-level APIs, provider clients, and utilities:</p> <ul> <li>Provider APIs: Interfaces for Git hosting providers like GitHub</li> <li>Data Models: Pydantic models for validation and serialization</li> <li>Authentication: Token management and credential handling</li> <li>Utility Functions: Conversion, rate limiting, and helpers</li> </ul>"},{"location":"development/architecture/#key-python-modules","title":"Key Python Modules","text":"<ul> <li><code>gitbench/__init__.py</code>: Main package exports</li> <li><code>gitbench/providers/github.py</code>: GitHub API client</li> <li><code>gitbench/providers/token_manager.py</code>: API token management</li> <li><code>gitbench/models/repo.py</code>: Pydantic wrappers for Rust objects</li> <li><code>gitbench/models/common.py</code>: Common data models</li> <li><code>gitbench/utils/auth.py</code>: Authentication utilities</li> <li><code>gitbench/utils/converters.py</code>: Data conversion utilities</li> <li><code>gitbench/utils/rate_limit.py</code>: Rate limiting helpers</li> </ul>"},{"location":"development/architecture/#implementation-split","title":"Implementation Split","text":"<p>The implementation responsibilities are split between Rust and Python:</p>"},{"location":"development/architecture/#implemented-in-rust","title":"Implemented in Rust","text":"<ul> <li>Repository Cloning: Efficient Git clone operations with progress reporting</li> <li>Blame Analysis: High-performance file blame extraction</li> <li>Commit Extraction: Fast commit history analysis</li> <li>Core Repository Management: Basic repository operations</li> </ul>"},{"location":"development/architecture/#implemented-in-python","title":"Implemented in Python","text":"<ul> <li>GitHub API Client: Async HTTP interface to GitHub API</li> <li>Token Management: Smart token rotation and rate limit handling</li> <li>Data Validation: Pydantic models for request/response validation</li> <li>Authentication: Credential management and storage</li> <li>Utilities: Conversion to pandas DataFrames, data formatting</li> </ul>"},{"location":"development/architecture/#python-rust-bridge","title":"Python-Rust Bridge","text":"<p>The Python-Rust bridge is implemented using PyO3:</p> <ul> <li>Exposed Classes: <code>RepoManager</code>, <code>CloneStatus</code>, <code>CloneTask</code></li> <li>Async Bridge: Integration between Tokio and asyncio</li> <li>Memory Management: Handles reference counting between Python and Rust</li> <li>Error Propagation: Converts Rust errors to Python exceptions</li> </ul>"},{"location":"development/architecture/#concurrency-model","title":"Concurrency Model","text":"<p>gitbench uses a hybrid concurrency model:</p> <ul> <li>Rust: Uses Tokio for asynchronous operations</li> <li>Python: Exposes asyncio coroutines for non-blocking operations</li> <li>Bridge: Uses pyo3-async-runtimes to bridge between Tokio and asyncio</li> </ul> <p>Git operations that could block (like cloning large repositories) are executed asynchronously to avoid blocking the main thread.</p>"},{"location":"development/architecture/#memory-management","title":"Memory Management","text":"<p>gitbench optimizes memory usage through:</p> <ul> <li>Rust Ownership: Ensures memory safety without garbage collection</li> <li>Arc Sharing: Shared resources use atomic reference counting</li> <li>Temporary Directories: Automatic cleanup of temporary clone directories</li> <li>Stream Processing: Large result sets can be processed as streams</li> </ul>"},{"location":"development/architecture/#error-handling","title":"Error Handling","text":"<p>Error handling follows a consistent pattern:</p> <ul> <li>Rust Results: Functions return <code>Result&lt;T, E&gt;</code> for error handling</li> <li>Python Exceptions: Rust errors are converted to appropriate Python exceptions</li> <li>Status Objects: Operations provide status objects with detailed information</li> <li>Structured Errors: Error types are well-defined and informative</li> </ul>"},{"location":"development/architecture/#performance-optimizations","title":"Performance Optimizations","text":"<p>Several performance optimizations are employed:</p> <ul> <li>Native Git Operations: Critical Git operations are implemented in Rust</li> <li>Parallel Processing: Multiple repositories processed concurrently</li> <li>Async I/O: Non-blocking I/O operations for network and file system</li> <li>Tokio Runtime: Efficient task scheduler for concurrent operations</li> <li>PyO3 Zero-Copy: Minimizes data copying between Python and Rust</li> </ul>"},{"location":"development/architecture/#security-considerations","title":"Security Considerations","text":"<p>gitbench prioritizes security:</p> <ul> <li>Token Management: Secure handling of API tokens</li> <li>Temporary Storage: Secure creation and cleanup of temporary directories</li> <li>Input Validation: Comprehensive validation of all inputs</li> <li>Safe Defaults: Conservative defaults for all operations</li> </ul>"},{"location":"development/architecture/#related-documentation","title":"Related Documentation","text":"<ul> <li>Python-Rust Bridge: Details on the PyO3 integration</li> <li>Contributing Guide: How to contribute to gitbench</li> <li>Performance Tips: Tips for maximizing performance</li> </ul>"},{"location":"development/ci-setup/","title":"CI Setup for gitbench","text":"<p>This document explains how to set up the CI environment for gitbench, particularly for running tests that require GitHub API authentication.</p>"},{"location":"development/ci-setup/#github-token-for-ci","title":"GitHub Token for CI","text":"<p>Several gitbench tests require a valid GitHub API token to interact with the GitHub API. This section explains how to set up a token for CI use.</p>"},{"location":"development/ci-setup/#creating-a-github-api-token","title":"Creating a GitHub API Token","text":"<ol> <li>Log in to your GitHub account</li> <li>Go to Settings \u2192 Developer settings \u2192 Personal access tokens \u2192 Fine-grained tokens</li> <li>Click \"Generate new token\"</li> <li>Give your token a descriptive name, e.g., \"gitbench CI Tests\"</li> <li>Set an expiration date (or select \"No expiration\" for CI tokens)</li> <li>Select the repository scope to limit the token to your repository</li> <li>Set the following permissions:</li> <li>Repository: Read-only access</li> <li>Metadata: Read-only access</li> </ol>"},{"location":"development/ci-setup/#adding-the-token-to-github-secrets","title":"Adding the Token to GitHub Secrets","text":"<p>To make the token available to GitHub Actions:</p> <ol> <li>Go to your repository's settings</li> <li>Click on \"Secrets and variables\" \u2192 \"Actions\"</li> <li>Click \"New repository secret\"</li> <li>Set the name to <code>GH_API_TOKEN</code></li> <li>Paste the token value in the secret value field</li> <li>Click \"Add secret\"</li> </ol> <p>This token will now be available to GitHub Actions workflows as <code>${{ secrets.GH_API_TOKEN }}</code>.</p>"},{"location":"development/ci-setup/#model-validation-workflow","title":"Model Validation Workflow","text":"<p>The model validation workflow (<code>model-validation.yml</code>) automatically:</p> <ol> <li>Runs whenever code in the <code>gitbench/models/</code> or <code>gitbench/providers/</code> directories is changed</li> <li>Builds the Rust extension with maturin</li> <li>Runs the Pydantic model validation tests</li> <li>Uses the <code>GH_API_TOKEN</code> secret for API authentication</li> </ol>"},{"location":"development/ci-setup/#local-testing","title":"Local Testing","text":"<p>For local testing of the model validation, you can:</p> <ol> <li>Create a <code>.env</code> file in the project root</li> <li>Add your GitHub token: <code>GITHUB_TOKEN=your_token_here</code></li> <li>Run the tests: <code>pytest tests/test_github_models.py -v</code></li> </ol> <p>The test script will automatically load the token from the <code>.env</code> file if the <code>GITHUB_TOKEN</code> environment variable is not set.</p>"},{"location":"development/ci-setup/#security-considerations","title":"Security Considerations","text":"<ul> <li>Never commit API tokens to the repository</li> <li>Use repository secrets for storing sensitive credentials</li> <li>Set appropriate token scopes to limit access (read-only permissions when possible)</li> <li>Regularly rotate tokens, especially if used for CI/CD pipelines</li> </ul>"},{"location":"development/ci-setup/#troubleshooting-ci-issues","title":"Troubleshooting CI Issues","text":"<p>If the GitHub API token tests fail in CI:</p> <ol> <li>Check if the token is correctly added as a repository secret</li> <li>Verify the token has sufficient permissions</li> <li>Check if the token has expired</li> <li>Check the GitHub API status page for any outages</li> <li>Review the error message for rate limit issues</li> </ol>"},{"location":"development/contributing/","title":"Contributing to gitbench","text":"<p>Thank you for your interest in contributing to gitbench! This document provides guidelines and instructions for contributing to the project. We welcome contributions of all kinds, including bug reports, feature requests, documentation improvements, and code changes.</p>"},{"location":"development/contributing/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Code of Conduct</li> <li>Getting Started</li> <li>Development Environment</li> <li>Building and Testing</li> <li>Contribution Workflow</li> <li>Coding Standards</li> <li>Documentation</li> <li>Issue Reporting</li> <li>Pull Requests</li> <li>Release Process</li> </ul>"},{"location":"development/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>By participating in this project, you agree to abide by our Code of Conduct. We expect all contributors to be respectful, inclusive, and considerate of others.</p>"},{"location":"development/contributing/#getting-started","title":"Getting Started","text":""},{"location":"development/contributing/#prerequisites","title":"Prerequisites","text":"<p>Before you begin contributing, ensure you have the following installed:</p> <ul> <li>Rust (1.60+)</li> <li>Python (3.8+)</li> <li>Cargo and pip</li> <li>Git</li> </ul>"},{"location":"development/contributing/#fork-and-clone","title":"Fork and Clone","text":"<ol> <li>Fork the repository on GitHub</li> <li>Clone your fork locally:</li> </ol> <pre><code>git clone https://github.com/bmeddeb/gitbench.git\ncd gitbench\n</code></pre> <ol> <li>Add the upstream repository as a remote:</li> </ol> <pre><code>git remote add upstream https://github.com/bmeddeb/gitbench.git\n</code></pre>"},{"location":"development/contributing/#development-environment","title":"Development Environment","text":""},{"location":"development/contributing/#setup","title":"Setup","text":"<ol> <li>Create a virtual environment (optional but recommended):</li> </ol> <pre><code>python -m venv .venv\nsource .venv/bin/activate  # On Windows, use .venv\\Scripts\\activate\n</code></pre> <ol> <li>Install development dependencies:</li> </ol> <pre><code>pip install -e \".[dev]\"\n</code></pre> <ol> <li>Install Rust dependencies:</li> </ol> <pre><code>cargo install maturin\n</code></pre>"},{"location":"development/contributing/#building","title":"Building","text":"<p>To build the project locally:</p> <pre><code>maturin develop\n</code></pre> <p>This will compile the Rust code and install the Python package in development mode.</p>"},{"location":"development/contributing/#building-and-testing","title":"Building and Testing","text":""},{"location":"development/contributing/#running-tests","title":"Running Tests","text":"<p>To run the Rust tests:</p> <pre><code>cargo test\n</code></pre> <p>To run the Python tests:</p> <pre><code>pytest\n</code></pre> <p>To run linting:</p> <pre><code># Python\nblack .\nisort .\nflake8\n\n# Rust\ncargo clippy\ncargo fmt --check\n</code></pre>"},{"location":"development/contributing/#contribution-workflow","title":"Contribution Workflow","text":"<ol> <li> <p>Choose an Issue: Start by finding an issue you'd like to work on, or create a new one if you've identified a bug or enhancement.</p> </li> <li> <p>Create a Branch: Create a branch for your work based on the <code>main</code> branch:</p> </li> </ol> <pre><code>git checkout -b feature/your-feature-name\n</code></pre> <p>Use a prefix like <code>feature/</code>, <code>bugfix/</code>, <code>docs/</code>, etc., to indicate the type of change.</p> <ol> <li> <p>Make Changes: Implement your changes, following the coding standards below.</p> </li> <li> <p>Write Tests: Add tests that cover your changes.</p> </li> <li> <p>Update Documentation: Update any relevant documentation.</p> </li> <li> <p>Commit Changes: Commit your changes with a descriptive commit message:</p> </li> </ol> <pre><code>git commit -m \"Add feature X to solve problem Y\"\n</code></pre> <ol> <li>Push to GitHub: Push your branch to your fork:</li> </ol> <pre><code>git push origin feature/your-feature-name\n</code></pre> <ol> <li>Create a Pull Request: Create a pull request from your branch to the main repository's <code>main</code> branch.</li> </ol>"},{"location":"development/contributing/#coding-standards","title":"Coding Standards","text":""},{"location":"development/contributing/#rust-code-style","title":"Rust Code Style","text":"<ul> <li>Follow the Rust Style Guide</li> <li>Use <code>cargo fmt</code> to format your code</li> <li>Use <code>cargo clippy</code> to check for common issues</li> <li>Use meaningful variable and function names</li> <li>Document public functions with doc comments</li> <li>Prefer returning <code>Result</code> types for functions that can fail</li> </ul>"},{"location":"development/contributing/#python-code-style","title":"Python Code Style","text":"<ul> <li>Follow PEP 8</li> <li>Use Black for code formatting</li> <li>Use isort for import sorting</li> <li>Use type hints for function arguments and return values</li> <li>Document functions and classes with docstrings</li> <li>Prefer async/await for asynchronous code</li> </ul>"},{"location":"development/contributing/#commit-messages","title":"Commit Messages","text":"<ul> <li>Use clear, descriptive commit messages</li> <li>Start with a short summary line (max 72 characters)</li> <li>Include a more detailed description if necessary</li> <li>Reference issue numbers when relevant (e.g., \"Fixes #123\")</li> </ul>"},{"location":"development/contributing/#documentation","title":"Documentation","text":"<p>Good documentation is essential for any project. When contributing:</p> <ul> <li>Update the README.md if your changes affect usage, installation, or features</li> <li>Document new functions, classes, and modules with docstrings</li> <li>Update or add Markdown files in the docs/ directory as needed</li> <li>Add example code demonstrating new features</li> </ul>"},{"location":"development/contributing/#documentation-standards","title":"Documentation Standards","text":"<ul> <li>Use Markdown for all documentation</li> <li>Use clear, concise language</li> <li>Include code examples when relevant</li> <li>Break up long documentation with headings and lists</li> <li>Link to other relevant documentation when appropriate</li> </ul>"},{"location":"development/contributing/#issue-reporting","title":"Issue Reporting","text":"<p>When reporting issues:</p> <ol> <li>Use the issue template if provided</li> <li>Include a clear description of the problem</li> <li>Provide steps to reproduce the issue</li> <li>Include relevant information like OS, Python/Rust version, etc.</li> <li>Attach logs or screenshots if applicable</li> </ol>"},{"location":"development/contributing/#pull-requests","title":"Pull Requests","text":"<p>When submitting a pull request:</p> <ol> <li>Fill out the pull request template completely</li> <li>Link to any related issues</li> <li>Describe the changes and the problem they solve</li> <li>List any new dependencies introduced</li> <li>Include screenshots or output examples for UI/UX changes</li> <li>Ensure all tests pass</li> <li>Be responsive to code review feedback</li> </ol>"},{"location":"development/contributing/#release-process","title":"Release Process","text":"<p>The gitbench release process is as follows:</p> <ol> <li>Version bumps follow Semantic Versioning</li> <li>Releases are tagged in Git with the version number (e.g., <code>v1.0.0</code>)</li> <li>Release notes are created for each release</li> <li>Releases are published to PyPI</li> </ol>"},{"location":"development/contributing/#release-checklist","title":"Release Checklist","text":"<p>Before a release:</p> <ul> <li>All tests must pass</li> <li>Documentation must be up-to-date</li> <li>CHANGELOG.md must be updated</li> <li>Version number must be updated in appropriate files</li> </ul>"},{"location":"development/contributing/#architecture-overview","title":"Architecture Overview","text":"<p>For a deeper understanding of gitbench's architecture, see the Architecture Documentation and Python/Rust Bridge pages.</p>"},{"location":"development/contributing/#getting-help","title":"Getting Help","text":"<p>If you need help with contributing:</p> <ul> <li>Ask questions in the issue where you're contributing</li> <li>Join our community chat/forum (if available)</li> <li>Reach out to maintainers via email</li> </ul> <p>Thank you for contributing to gitbench! Your efforts help make this project better for everyone.</p>"},{"location":"development/model-validation/","title":"Model Validation in gitbench","text":"<p>This document describes how gitbench uses Pydantic models to validate and structure data from various Git provider APIs, specifically focusing on GitHub.</p>"},{"location":"development/model-validation/#github-api-response-validation","title":"GitHub API Response Validation","text":"<p>gitbench uses Pydantic models to validate and structure the responses from the GitHub API. These models ensure that the data is correctly typed and structured for use in the application.</p>"},{"location":"development/model-validation/#models-overview","title":"Models Overview","text":"<p>The following Pydantic models are used for GitHub API responses:</p> <ul> <li><code>UserInfo</code>: Contains user information including ID, login, name, email, etc.</li> <li><code>RepoInfo</code>: Basic repository information</li> <li><code>RepoDetails</code>: Detailed repository information (extends RepoInfo)</li> <li><code>RateLimitInfo</code>: Rate limit information</li> <li><code>BranchInfo</code>: Branch information </li> <li><code>ContributorInfo</code>: Contributor information</li> <li><code>CommitRef</code>: Reference to a commit (used in BranchInfo)</li> </ul>"},{"location":"development/model-validation/#field-type-mapping","title":"Field Type Mapping","text":"<p>The models map GitHub API response fields to Pydantic field types as follows:</p> GitHub API Field Type Pydantic Field Type Integer IDs <code>int</code> Strings <code>str</code> Booleans <code>bool</code> Optional fields <code>Optional[Type]</code> Dates <code>str</code> (ISO8601 format) Nested objects Nested Pydantic models Arrays <code>List[Type]</code>"},{"location":"development/model-validation/#special-handling-cases","title":"Special Handling Cases","text":"<p>Some GitHub API responses require special handling:</p> <ol> <li>Rate Limit Response: GitHub returns a <code>reset</code> field, which we map to <code>reset_time</code> in our <code>RateLimitInfo</code> model.</li> <li>Branch Information: GitHub returns branch information with a nested <code>commit</code> object. We extract the SHA for backward compatibility while also storing the full commit object.</li> <li>Repository Details: GitHub returns a large number of fields for repository details. We map the most commonly used fields while providing a <code>raw_data</code> field for access to all data.</li> </ol>"},{"location":"development/model-validation/#testing-model-validation","title":"Testing Model Validation","text":"<p>gitbench includes tests to verify that the Pydantic models correctly validate GitHub API responses.</p>"},{"location":"development/model-validation/#running-tests","title":"Running Tests","text":"<p>To run the model validation tests:</p> <ol> <li>Set the <code>GITHUB_TOKEN</code> environment variable with a valid GitHub token.</li> <li>Run the tests with pytest:</li> </ol> <pre><code>GITHUB_TOKEN=\"your_token_here\" pytest tests/test_github_models.py -v\n</code></pre>"},{"location":"development/model-validation/#test-coverage","title":"Test Coverage","text":"<p>The tests verify:</p> <ol> <li>Field Types: Tests ensure that fields have the correct types (e.g., IDs are integers, names are strings).</li> <li>Required Fields: Tests verify that all required fields are present in the API responses.</li> <li>Optional Fields: Tests check that optional fields can be absent without causing validation errors.</li> <li>Nested Objects: Tests validate that nested objects (like owner information in repositories) are correctly parsed.</li> <li>Implementation Consistency: Tests compare the Python and Rust implementations to ensure they return compatible models.</li> </ol>"},{"location":"development/model-validation/#debugging-model-validation-issues","title":"Debugging Model Validation Issues","text":"<p>When debugging model validation issues:</p> <ol> <li>Print Raw Response: Log the raw JSON response from the API to identify any missing or incorrectly formatted fields.</li> <li>Use Validation Errors: Pydantic provides detailed validation error messages that can help identify which fields are problematic.</li> <li>Check Conversion Logic: The <code>_convert_to_model</code> method in the GitHub client performs additional conversions before validation.</li> </ol>"},{"location":"development/model-validation/#extending-models","title":"Extending Models","text":"<p>When extending models to support new GitHub API fields:</p> <ol> <li>Review the GitHub API documentation for the field types and requirements.</li> <li>Add new fields to the appropriate Pydantic model with correct types and default values.</li> <li>Update any conversion logic in the <code>_convert_to_model</code> method if needed.</li> <li>Add tests for the new fields to verify they're correctly validated.</li> </ol>"},{"location":"development/python-rust-bridge/","title":"Python-Rust Bridge","text":"<p>gitbench uses a hybrid architecture with a Rust core for performance-critical Git operations and Python for high-level APIs and provider clients. This page explains how the Python-Rust bridge works and how to use it effectively.</p>"},{"location":"development/python-rust-bridge/#architecture-overview","title":"Architecture Overview","text":"<p>gitbench's architecture consists of three main layers:</p> <ol> <li>Rust Core Library: High-performance, memory-safe implementation of key Git operations (cloning, blame, commit analysis)</li> <li>PyO3 Bridge Layer: Exposes Rust functionality to Python with asyncio integration</li> <li>Python Interface: User-friendly API with provider clients, data models, and utility functions</li> </ol>"},{"location":"development/python-rust-bridge/#how-pyo3-is-used-in-gitbench","title":"How PyO3 is Used in gitbench","text":"<p>The PyO3 library allows gitbench to expose Rust functionality to Python in a way that feels natural to Python developers. Here's how it works:</p>"},{"location":"development/python-rust-bridge/#rust-struct-definitions-with-pyo3-annotations","title":"Rust Struct Definitions with PyO3 Annotations","text":"<pre><code>use pyo3::prelude::*;\n\n#[pyclass(name = \"RepoManager\", module = \"gitbench\")]\nstruct RepoManager {\n    inner: Arc&lt;InternalRepoManagerLogic&gt;,\n}\n\n#[pymethods]\nimpl RepoManager {\n    #[new]\n    fn new(urls: Vec&lt;String&gt;, github_username: String, github_token: String) -&gt; Self {\n        let string_urls: Vec&lt;&amp;str&gt; = urls.iter().map(|s| s.as_str()).collect();\n        Self {\n            inner: Arc::new(InternalRepoManagerLogic::new(\n                &amp;string_urls,\n                &amp;github_username,\n                &amp;github_token,\n            )),\n        }\n    }\n\n    /// Clones all repositories configured in this manager instance asynchronously.\n    #[pyo3(name = \"clone_all\")]\n    fn clone_all&lt;'py&gt;(&amp;self, py: Python&lt;'py&gt;) -&gt; PyResult&lt;Bound&lt;'py, PyAny&gt;&gt; {\n        let inner = Arc::clone(&amp;self.inner);\n        tokio::future_into_py(py, async move {\n            inner.clone_all().await;\n            Python::with_gil(|py| Ok(py.None()))\n        })\n    }\n\n    // ...other methods\n}\n</code></pre>"},{"location":"development/python-rust-bridge/#async-bridge-with-pyo3-async-runtimes","title":"Async Bridge with pyo3-async-runtimes","text":"<p>gitbench uses pyo3-async-runtimes to bridge between Rust's async model (Tokio) and Python's asyncio:</p> <pre><code>use pyo3::prelude::*;\nuse pyo3_async_runtimes::tokio;\n\n#[pymethods]\nimpl RepoManager {\n    /// Performs 'git blame' on multiple files within a cloned repository asynchronously.\n    #[pyo3(name = \"bulk_blame\")]\n    fn bulk_blame&lt;'py&gt;(\n        &amp;self,\n        py: Python&lt;'py&gt;,\n        repo_path: String,\n        file_paths: Vec&lt;String&gt;,\n    ) -&gt; PyResult&lt;Bound&lt;'py, PyAny&gt;&gt; {\n        let inner = Arc::clone(&amp;self.inner);\n        tokio::future_into_py(py, async move {\n            let result_map = inner\n                .bulk_blame(&amp;PathBuf::from(repo_path), file_paths)\n                .await;\n            Python::with_gil(|py| -&gt; PyResult&lt;Py&lt;PyAny&gt;&gt; {\n                // Convert result to Python object\n                // ...\n            })\n        })\n    }\n}\n</code></pre>"},{"location":"development/python-rust-bridge/#whats-implemented-in-rust-vs-python","title":"What's Implemented in Rust vs Python","text":"<p>gitbench uses a strategic split between Rust and Python implementations:</p>"},{"location":"development/python-rust-bridge/#rust-implementation-performance-critical-operations","title":"Rust Implementation (Performance-Critical Operations)","text":"<p>The following operations are implemented in Rust for maximum performance:</p> Rust Module Functionality <code>clone.rs</code> Repository cloning with progress monitoring <code>blame.rs</code> Git blame analysis for file content <code>commits.rs</code> Commit history extraction and analysis <code>repo.rs</code> Core repository management logic <p>These operations benefit significantly from Rust's performance characteristics, including: - Memory efficiency through Rust's ownership model - Parallel processing with Rayon for commit analysis - No Python GIL limitations during intensive operations - Direct use of git2-rs for native Git operations</p>"},{"location":"development/python-rust-bridge/#python-implementation-api-provider-layer","title":"Python Implementation (API &amp; Provider Layer)","text":"<p>The following components are implemented in Python:</p> Python Module Functionality <code>providers/github.py</code> GitHub API client <code>providers/token_manager.py</code> Token management with rotation <code>providers/base.py</code> Provider abstractions and interfaces <code>models/common.py</code> Data models for API requests/responses <code>models/repo.py</code> Wrappers for Rust objects with Pydantic <code>utils/auth.py</code> Authentication utilities <code>utils/converters.py</code> Data conversion utilities <code>utils/rate_limit.py</code> Rate limiting logic <p>These components leverage Python's strengths: - Rich ecosystem for HTTP requests and API clients - Pydantic for data validation and serialization - Intuitive asyncio interface for Python users - Easier integration with Python frameworks</p>"},{"location":"development/python-rust-bridge/#data-conversion-between-python-and-rust","title":"Data Conversion Between Python and Rust","text":"<p>gitbench handles data conversion between Python and Rust through PyO3:</p>"},{"location":"development/python-rust-bridge/#python-to-rust","title":"Python to Rust","text":"<ul> <li>Python strings \u2192 Rust <code>String</code></li> <li>Python lists \u2192 Rust <code>Vec&lt;T&gt;</code></li> <li>Python dicts \u2192 Rust <code>HashMap&lt;K, V&gt;</code> or custom structs</li> <li>Python None \u2192 Rust <code>Option&lt;T&gt;</code> as <code>None</code></li> </ul>"},{"location":"development/python-rust-bridge/#rust-to-python","title":"Rust to Python","text":"<ul> <li>Rust <code>String</code> \u2192 Python strings</li> <li>Rust <code>Vec&lt;T&gt;</code> \u2192 Python lists</li> <li>Rust <code>HashMap&lt;K, V&gt;</code> \u2192 Python dicts</li> <li>Rust structs \u2192 Python objects via PyO3</li> <li>Rust <code>Result&lt;T, E&gt;</code> \u2192 Python return value or exception</li> <li>Rust <code>Option&lt;T&gt;</code> \u2192 Python value or None</li> </ul>"},{"location":"development/python-rust-bridge/#exposed-rust-objects-as-python-classes","title":"Exposed Rust Objects as Python Classes","text":"<p>The Rust library exposes the following classes to Python:</p> Rust Class Python Class Description <code>RepoManager</code> <code>gitbench.RepoManager</code> Main entry point for repository operations <code>ExposedCloneStatus</code> <code>gitbench.CloneStatus</code> Repository clone status information <code>ExposedCloneTask</code> <code>gitbench.CloneTask</code> Repository clone task with status"},{"location":"development/python-rust-bridge/#performance-considerations","title":"Performance Considerations","text":"<p>The hybrid Rust/Python architecture offers significant performance benefits:</p> <ul> <li>Clone Operations: Parallel, efficient repository cloning</li> <li>Blame Analysis: Fast line-by-line blame extraction (5-10x faster than pure Python)</li> <li>Commit Processing: Efficient commit history extraction with parallel processing</li> <li>Memory Usage: Lower memory footprint for large repositories</li> <li>GIL Avoidance: Compute-intensive operations run outside Python's GIL</li> </ul>"},{"location":"development/python-rust-bridge/#contributing-to-the-bridge-layer","title":"Contributing to the Bridge Layer","text":"<p>When contributing to the Python-Rust bridge:</p> <ol> <li>Determine whether the new functionality is performance-critical (use Rust) or API-related (use Python)</li> <li>For Rust changes:</li> <li>Implement the core functionality in the appropriate Rust module</li> <li>Add PyO3 bindings to expose the functionality to Python</li> <li>Update tests for both Rust and Python interfaces</li> <li>For Python changes:</li> <li>Implement in the appropriate Python module</li> <li>Ensure compatibility with the Rust-exposed objects</li> <li>Add Python-specific tests</li> </ol>"},{"location":"development/python-rust-bridge/#related-documentation","title":"Related Documentation","text":"<ul> <li>Architecture Overview</li> <li>Contributing Guide</li> <li>Performance Tips</li> </ul>"},{"location":"development/repo-model-validation/","title":"Repository Model Validation in gitbench","text":"<p>This document describes the validation approach for the repository-related models in gitbench, including <code>CloneStatus</code>, <code>CloneTask</code>, and <code>RepoManager</code>.</p>"},{"location":"development/repo-model-validation/#overview","title":"Overview","text":"<p>gitbench implements a dual architecture where core functionality is written in Rust for performance, while Python code provides a user-friendly interface. The repository management models bridge these two worlds by:</p> <ol> <li>Defining Pydantic models that mirror the Rust-generated classes</li> <li>Providing conversion methods between Rust objects and Pydantic models</li> <li>Implementing validation logic to ensure data integrity</li> </ol>"},{"location":"development/repo-model-validation/#models","title":"Models","text":""},{"location":"development/repo-model-validation/#clonestatustype","title":"CloneStatusType","text":"<p>An enumeration of possible clone status types: - <code>QUEUED</code>: The cloning task is waiting to start - <code>CLONING</code>: The repository is currently being cloned - <code>COMPLETED</code>: The repository has been successfully cloned - <code>FAILED</code>: The cloning operation failed</p>"},{"location":"development/repo-model-validation/#clonestatus","title":"CloneStatus","text":"<p>A model representing the current status of a repository cloning operation: - <code>status_type</code>: The type of status (from CloneStatusType) - <code>progress</code>: The percentage of completion (0-100) if cloning, or None - <code>error</code>: An error message if failed, or None</p>"},{"location":"development/repo-model-validation/#clonetask","title":"CloneTask","text":"<p>A model representing a repository cloning task and its current status: - <code>url</code>: The URL of the repository being cloned - <code>status</code>: The current status (CloneStatus) - <code>temp_dir</code>: The path to the temporary directory where the repository was cloned, or None</p>"},{"location":"development/repo-model-validation/#repomanager","title":"RepoManager","text":"<p>A wrapper class that provides the same interface as the Rust RepoManager but converts the results to Pydantic models for better serialization and validation.</p>"},{"location":"development/repo-model-validation/#validation-approach","title":"Validation Approach","text":""},{"location":"development/repo-model-validation/#type-validation","title":"Type Validation","text":"<p>Pydantic handles basic type validation: - <code>status_type</code> must be a valid CloneStatusType enum value - <code>progress</code> must be an integer or None - <code>error</code> must be a string or None - <code>url</code> must be a string - <code>temp_dir</code> must be a string or None</p>"},{"location":"development/repo-model-validation/#semantic-validation","title":"Semantic Validation","text":"<p>The models include semantic validation through their structure: - <code>progress</code> is only meaningful when <code>status_type</code> is <code>CLONING</code> - <code>error</code> is only meaningful when <code>status_type</code> is <code>FAILED</code> - <code>temp_dir</code> is only set when a repository has been successfully cloned</p>"},{"location":"development/repo-model-validation/#conversion-from-rust","title":"Conversion from Rust","text":"<p>The <code>from_rust</code> class methods handle conversion from Rust objects to Pydantic models: - <code>CloneStatus.from_rust()</code> converts a Rust CloneStatus - <code>CloneTask.from_rust()</code> converts a Rust CloneTask</p>"},{"location":"development/repo-model-validation/#testing","title":"Testing","text":"<p>The models are tested using both unit tests and integration tests:</p>"},{"location":"development/repo-model-validation/#unit-tests","title":"Unit Tests","text":"<ul> <li>Tests for model creation and validation</li> <li>Tests for enum value correctness</li> <li>Tests for field constraints</li> </ul>"},{"location":"development/repo-model-validation/#integration-tests-with-mock-rust-objects","title":"Integration Tests with Mock Rust Objects","text":"<p>Since the actual Rust objects might not be available in all test environments, we use mock classes that simulate the behavior of the Rust implementations: - <code>MockRustCloneStatus</code> - <code>MockRustCloneTask</code> - <code>MockRustRepoManager</code></p> <p>These mocks allow testing the Python-Rust conversion logic without requiring the actual Rust implementation.</p>"},{"location":"development/repo-model-validation/#debugging-tips","title":"Debugging Tips","text":"<p>When debugging issues with these models:</p> <ol> <li>Check the <code>status_type</code> values - they should match one of the enum values</li> <li>For models with a <code>CLONING</code> status, verify that <code>progress</code> is an integer between 0 and 100</li> <li>For models with a <code>FAILED</code> status, check the <code>error</code> field for details</li> <li>Verify that the Rust implementation is available by checking <code>RUST_AVAILABLE</code></li> </ol>"},{"location":"development/repo-model-validation/#adding-new-fields","title":"Adding New Fields","text":"<p>When adding new fields to these models:</p> <ol> <li>Add the field to the Pydantic model with appropriate type hints and defaults</li> <li>Update the <code>from_rust</code> method to handle the new field</li> <li>Add tests for the new field</li> <li>Update this documentation to reflect the changes</li> </ol>"},{"location":"examples/basic-usage/","title":"Basic Usage Example","text":"<p>This example demonstrates the fundamental operations of gitbench, including initializing a repository manager, cloning repositories, monitoring clone status, and analyzing repository data.</p>"},{"location":"examples/basic-usage/#code-example","title":"Code Example","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\ngitbench Basic Usage Example\n\nThis example demonstrates how to use the gitbench library to:\n1. Initialize a repository manager\n2. Clone repositories\n3. Check clone statuses\n4. Analyze blame information\n5. Analyze commit history\n\"\"\"\n\nimport asyncio\nimport os\n\nfrom gitbench import RepoManager\n\n# GitHub credentials - replace with your own or use environment variables\nGITHUB_USERNAME = os.environ.get(\"GITHUB_USERNAME\", \"your-username\")\nGITHUB_TOKEN = os.environ.get(\"GITHUB_TOKEN\", \"your-personal-access-token\")\n\n# Repository URLs to analyze\nREPO_URLS = [\n    # Example - you can change to your repositories\n    \"https://github.com/bmeddeb/gradelib\",\n]\n\n\nasync def main():\n    # Initialize the repository manager\n    print(\"Initializing repository manager...\")\n    repo_manager = RepoManager(\n        urls=REPO_URLS, github_username=GITHUB_USERNAME, github_token=GITHUB_TOKEN\n    )\n\n    # Start cloning repositories asynchronously\n    print(f\"Starting clone of {len(REPO_URLS)} repositories...\")\n    # PyO3 already returns futures, not coroutines\n    clone_future = repo_manager.clone_all()\n\n    # Monitor cloning progress with a more detailed display\n    try:\n        # Continue monitoring until all repos are done (completed or failed)\n        previous_status = {}\n        while not clone_future.done():\n            # Get current status of all clone tasks\n            clone_tasks = await repo_manager.fetch_clone_tasks()\n\n            # Check if there are any active clones\n            all_done = True\n\n            # Clear terminal if supported (not on Windows)\n            if os.name != \"nt\":\n                os.system(\"clear\")\n            else:\n                os.system(\"cls\")\n\n            print(\"\\n===== REPOSITORY CLONE STATUS =====\\n\")\n\n            for url, task in clone_tasks.items():\n                status = task.status.status_type\n                progress = task.status.progress\n\n                # Status indicator\n                status_indicator = {\n                    \"queued\": \"\u231b QUEUED\",\n                    \"cloning\": \"\ud83d\udd04 CLONING\",\n                    \"completed\": \"\u2705 COMPLETED\",\n                    \"failed\": \"\u274c FAILED\",\n                }.get(status, status.upper())\n\n                # Print repository info\n                print(f\"Repository: {url}\")\n                print(f\"Status: {status_indicator}\")\n\n                # Show progress bar for cloning status\n                if status == \"cloning\" and progress is not None:\n                    bar_length = 30\n                    filled_length = int(bar_length * progress / 100)\n                    bar = \"\u2588\" * filled_length + \"\u2591\" * (bar_length - filled_length)\n                    print(f\"Progress: [{bar}] {progress}%\")\n\n                    # Print a message when progress changes significantly\n                    prev_progress = 0\n                    if (\n                        url in previous_status\n                        and previous_status[url][\"status\"] == \"cloning\"\n                    ):\n                        prev_progress = previous_status[url][\"progress\"] or 0\n\n                    if progress - prev_progress &gt;= 10:\n                        print(f\"  \u2191 Progress increased by {progress - prev_progress}%\")\n\n                # Show error if failed\n                if status == \"failed\" and task.status.error:\n                    print(f\"Error: {task.status.error}\")\n\n                # Show clone directory if available\n                if task.temp_dir:\n                    print(f\"Directory: {task.temp_dir}\")\n\n                # Update status tracking\n                previous_status[url] = {\"status\": status, \"progress\": progress}\n\n                # Check if we need to continue monitoring\n                if status not in [\"completed\", \"failed\"]:\n                    all_done = False\n\n                print(\"-\" * 50)\n\n            # Exit loop if all done\n            if all_done:\n                break\n\n            # Wait before refreshing\n            await asyncio.sleep(1)\n\n        # Make sure the clone_all task completes\n        await clone_future\n\n    except KeyboardInterrupt:\n        print(\n            \"\\nMonitoring interrupted. Clone operations may continue in the background.\"\n        )\n\n    print(\"\\nAll clone operations completed or failed.\")\n\n    # Find a successfully cloned repository to analyze\n    repo_path = None\n    clone_tasks = await repo_manager.fetch_clone_tasks()\n    for _, task in clone_tasks.items():\n        if task.status.status_type == \"completed\" and task.temp_dir:\n            repo_path = task.temp_dir\n            break\n\n    if not repo_path:\n        print(\"No repositories were cloned successfully.\")\n        return\n\n    # Analyze blame for a few files in the repository\n    print(f\"\\nAnalyzing blame information for files in {repo_path}...\")\n    # Find Python files in the repository (adjust for your specific case)\n    file_paths = []\n    for root, _, files in os.walk(repo_path):\n        for file in files:\n            if file.endswith(\".py\"):\n                file_paths.append(\n                    os.path.join(root, file).replace(repo_path + os.sep, \"\")\n                )\n                if len(file_paths) &gt;= 3:  # Limit to 3 files for this example\n                    break\n        if len(file_paths) &gt;= 3:\n            break\n\n    if file_paths:\n        print(f\"Analyzing blame for {len(file_paths)} files...\")\n        blame_results = await repo_manager.bulk_blame(repo_path, file_paths)\n\n        for file_path, blame_info in blame_results.items():\n            if isinstance(blame_info, list):  # Success case\n                print(f\"\\nBlame summary for {file_path}:\")\n                authors = {}\n                for line in blame_info:\n                    author = line[\"author_name\"]\n                    if author in authors:\n                        authors[author] += 1\n                    else:\n                        authors[author] = 1\n\n                print(\"Top contributors:\")\n                for author, count in sorted(\n                    authors.items(), key=lambda x: x[1], reverse=True\n                )[:3]:\n                    print(f\"  {author}: {count} lines\")\n            else:  # Error case\n                print(f\"Error analyzing {file_path}: {blame_info}\")\n\n    # Analyze commit history\n    print(\"\\nAnalyzing commit history...\")\n    commits = await repo_manager.extract_commits(repo_path)\n\n    if isinstance(commits, list):  # Success case\n        print(f\"Found {len(commits)} commits\")\n\n        # Show the 5 most recent commits\n        print(\"\\nRecent commits:\")\n        for commit in commits[:5]:\n            # Convert timestamp to a human-readable date\n            from datetime import datetime\n            timestamp = commit['author_timestamp']\n            date = datetime.fromtimestamp(timestamp)\n\n            print(f\"Commit: {commit['sha'][:7]}\")\n            print(f\"Author: {commit['author_name']}\")\n            print(f\"Date: {date.strftime('%Y-%m-%d %H:%M:%S')}\")\n            message_summary = commit[\"message\"].split(\"\\n\")[0][:50]\n            print(f\"Message: {message_summary}...\")\n            print(f\"Changes: +{commit['additions']} -{commit['deletions']}\")\n            print(\"\")\n    else:  # Error case\n        print(f\"Error analyzing commits: {commits}\")\n\n\nif __name__ == \"__main__\":\n    # Set up the event loop and run the main async function\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/basic-usage/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<p>This example demonstrates several key features of gitbench:</p> <ol> <li>Repository Management: Initializing and configuring a <code>RepoManager</code> instance</li> <li>Asynchronous Cloning: Non-blocking repository cloning with a future-based API</li> <li>Clone Progress Monitoring: Tracking the progress of clone operations with detailed status information</li> <li>Blame Analysis: Extracting and summarizing blame information for files</li> <li>Commit History Analysis: Extracting and analyzing commit history information</li> </ol>"},{"location":"examples/basic-usage/#running-the-example","title":"Running the Example","text":"<p>To run this example:</p> <ol> <li> <p>Install gitbench using pip:    <pre><code>pip install gitbench\n</code></pre></p> </li> <li> <p>Set your GitHub credentials as environment variables:    <pre><code>export GITHUB_USERNAME=your-username\nexport GITHUB_TOKEN=your-personal-access-token\n</code></pre></p> </li> <li> <p>Run the example:    <pre><code>python examples/basic_usage.py\n</code></pre></p> </li> </ol>"},{"location":"examples/basic-usage/#related-examples","title":"Related Examples","text":"<ul> <li>Clone Monitoring: More advanced techniques for monitoring clone operations</li> <li>GitHub Client: Working with the GitHub API client</li> </ul>"},{"location":"examples/clone-monitoring/","title":"Clone Monitoring Example","text":"<p>This example demonstrates how to clone repositories and monitor their cloning progress in real-time using gitbench. It includes a fancy terminal display with progress bars, status indicators, and estimated completion times.</p>"},{"location":"examples/clone-monitoring/#code-example","title":"Code Example","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\ngitbench Clone Monitoring Example\n\nThis example demonstrates how to use the gitbench library to:\n1. Initialize a repository manager\n2. Clone repositories\n3. Monitor cloning progress with detailed status updates\n\nThe example shows how to implement a progress bar and real-time monitoring\nof clone operations, with rich formatting.\n\"\"\"\n\nimport argparse\nimport asyncio\nimport os\nfrom datetime import datetime\n\nfrom gitbench import RepoManager\n\n# ANSI color codes for terminal output\nCOLORS = {\n    \"reset\": \"\\033[0m\",\n    \"bold\": \"\\033[1m\",\n    \"red\": \"\\033[31m\",\n    \"green\": \"\\033[32m\",\n    \"yellow\": \"\\033[33m\",\n    \"blue\": \"\\033[34m\",\n    \"magenta\": \"\\033[35m\",\n    \"cyan\": \"\\033[36m\",\n    \"white\": \"\\033[37m\",\n    \"bg_green\": \"\\033[42m\",\n    \"bg_red\": \"\\033[41m\",\n    \"bg_yellow\": \"\\033[43m\",\n    \"bg_blue\": \"\\033[44m\",\n}\n\n\ndef colorize(text, color):\n    \"\"\"Add color to terminal text if supported\"\"\"\n    if os.name == \"nt\":  # Windows terminals might not support ANSI\n        return text\n    return f\"{COLORS.get(color, '')}{text}{COLORS['reset']}\"\n\n\nasync def monitor_clones(repo_manager, clone_future, refresh_rate=1):\n    \"\"\"Monitor clone operations with a fancy display\"\"\"\n    previous_status = {}\n    start_time = datetime.now()\n\n    while True:\n        # Get current status of all clone tasks\n        clone_tasks = await repo_manager.fetch_clone_tasks()\n\n        # Check if all clones are done\n        active_clones = 0\n        completed_clones = 0\n        failed_clones = 0\n        queued_clones = 0\n\n        # Clear terminal\n        if os.name != \"nt\":\n            os.system(\"clear\")\n        else:\n            os.system(\"cls\")\n\n        # Print header\n        elapsed = datetime.now() - start_time\n        elapsed_str = f\"{elapsed.seconds // 60}m {elapsed.seconds % 60}s\"\n\n        print(colorize(f\"\\n\u23f1\ufe0f  CLONE MONITOR - Running for {elapsed_str}\", \"bold\"))\n        print(colorize(\"=\" * 60, \"bold\"))\n\n        # For each repository, show its status\n        for i, (url, task) in enumerate(clone_tasks.items(), 1):\n            status = task.status.status_type\n            progress = task.status.progress\n\n            # Count by status\n            if status == \"cloning\":\n                active_clones += 1\n            elif status == \"completed\":\n                completed_clones += 1\n            elif status == \"failed\":\n                failed_clones += 1\n            elif status == \"queued\":\n                queued_clones += 1\n\n            # Get repo name from URL\n            repo_name = url.split(\"/\")[-1]\n\n            # Status formatting\n            status_color = {\n                \"queued\": \"yellow\",\n                \"cloning\": \"blue\",\n                \"completed\": \"green\",\n                \"failed\": \"red\",\n            }.get(status, \"white\")\n\n            status_text = {\n                \"queued\": \"\u231b QUEUED\",\n                \"cloning\": \"\ud83d\udd04 CLONING\",\n                \"completed\": \"\u2705 COMPLETED\",\n                \"failed\": \"\u274c FAILED\",\n            }.get(status, status.upper())\n\n            # Get previous progress for comparison\n            prev_progress = 0\n            if url in previous_status and previous_status[url][\"status\"] == \"cloning\":\n                prev_progress = previous_status[url][\"progress\"] or 0\n\n            # Print repository header\n            print(\n                f\"\\n{i}. {colorize(repo_name, 'bold')} [{colorize(status_text, status_color)}]\"\n            )\n            print(f\"   URL: {url}\")\n\n            # Show progress bar for active clones\n            if status == \"cloning\" and progress is not None:\n                bar_length = 40\n                filled_length = int(bar_length * progress / 100)\n\n                # Format progress bar\n                bar_content = colorize(\"\u2588\" * filled_length, \"bg_green\") + \"\u2591\" * (\n                    bar_length - filled_length\n                )\n\n                # Show progress change indicators\n                progress_change = \"\"\n                if progress &gt; prev_progress:\n                    progress_change = colorize(\n                        f\" \u2191{progress - prev_progress}%\", \"green\"\n                    )\n\n                # Print progress information\n                print(f\"   Progress: [{bar_content}] {progress}%{progress_change}\")\n\n                # Estimated time (very rough)\n                if progress &gt; 0:\n                    elapsed_seconds = elapsed.total_seconds()\n                    estimated_total = elapsed_seconds * 100 / progress\n                    remaining = estimated_total - elapsed_seconds\n                    if remaining &gt; 0:\n                        remaining_min = int(remaining // 60)\n                        remaining_sec = int(remaining % 60)\n                        print(\n                            f\"   Estimated time remaining: ~{remaining_min}m {remaining_sec}s\"\n                        )\n\n            # Show error details for failed clones\n            if status == \"failed\" and task.status.error:\n                print(f\"   Error: {colorize(task.status.error, 'red')}\")\n\n            # Show clone directory if completed\n            if task.temp_dir:\n                print(f\"   Directory: {task.temp_dir}\")\n\n            # Store current status for the next iteration\n            previous_status[url] = {\"status\": status, \"progress\": progress}\n\n        # Print summary\n        print(colorize(\"\\n\" + \"=\" * 60, \"bold\"))\n        print(colorize(\"SUMMARY:\", \"bold\"))\n        print(f\"Total repositories: {len(clone_tasks)}\")\n        print(f\"Active clones: {colorize(str(active_clones), 'blue')}\")\n        print(f\"Completed: {colorize(str(completed_clones), 'green')}\")\n        print(f\"Failed: {colorize(str(failed_clones), 'red')}\")\n        print(f\"Queued: {colorize(str(queued_clones), 'yellow')}\")\n\n        # Exit condition: no active or queued clones\n        if (active_clones == 0 and queued_clones == 0) or clone_future.done():\n            print(colorize(\"\\nAll clone operations have completed!\", \"green\"))\n            break\n\n        # Wait before refreshing\n        await asyncio.sleep(refresh_rate)\n\n    return clone_tasks\n\n\nasync def main():\n    # Parse command line arguments\n    parser = argparse.ArgumentParser(description=\"Clone and monitor Git repositories\")\n    parser.add_argument(\n        \"--repos\",\n        \"-r\",\n        nargs=\"+\",\n        default=[\n            \"https://github.com/bmeddeb/gradelib\",\n            \"https://github.com/bmeddeb/SER402-Team3\",\n            \"https://github.com/bmeddeb/gitbench\",\n        ],\n        help=\"List of repository URLs to clone\",\n    )\n    parser.add_argument(\n        \"--username\",\n        \"-u\",\n        default=os.environ.get(\"GITHUB_USERNAME\", \"\"),\n        help=\"GitHub username (or set GITHUB_USERNAME env var)\",\n    )\n    parser.add_argument(\n        \"--token\",\n        \"-t\",\n        default=os.environ.get(\"GITHUB_TOKEN\", \"\"),\n        help=\"GitHub token (or set GITHUB_TOKEN env var)\",\n    )\n    parser.add_argument(\n        \"--refresh\",\n        \"-f\",\n        type=float,\n        default=1.0,\n        help=\"Refresh rate in seconds for the monitoring display\",\n    )\n\n    args = parser.parse_args()\n\n    # Initialize the repository manager\n    print(colorize(\"Initializing repository manager...\", \"bold\"))\n\n    if not args.username or not args.token:\n        print(\n            colorize(\n                \"Warning: GitHub credentials not provided. Anonymous access will be used.\",\n                \"yellow\",\n            )\n        )\n        print(\n            \"For better rate limits, provide credentials with --username and --token options\"\n        )\n        print(\"or set GITHUB_USERNAME and GITHUB_TOKEN environment variables.\\n\")\n\n    repo_manager = RepoManager(\n        urls=args.repos, github_username=args.username, github_token=args.token\n    )\n\n    # Start cloning repositories\n    print(colorize(f\"Starting clone of {len(args.repos)} repositories...\", \"bold\"))\n    # PyO3 already returns futures, not coroutines\n    clone_future = repo_manager.clone_all()\n\n    try:\n        # Monitor cloning progress\n        final_status = await monitor_clones(repo_manager, clone_future, args.refresh)\n\n        # Make sure clone_all completes\n        await clone_future\n\n        # Print final status\n        print(colorize(\"\\nFinal Status:\", \"bold\"))\n        for url, task in final_status.items():\n            status_color = \"green\" if task.status.status_type == \"completed\" else \"red\"\n            print(f\"\u2022 {url}: {colorize(task.status.status_type.upper(), status_color)}\")\n\n    except KeyboardInterrupt:\n        print(\n            colorize(\n                \"\\nMonitoring interrupted. Clone operations may continue in the background.\",\n                \"yellow\",\n            )\n        )\n        print(\"You can run this script again to resume monitoring.\")\n\n\nif __name__ == \"__main__\":\n    # Set up the event loop and run the main async function\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/clone-monitoring/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<p>This example demonstrates several key features of gitbench's clone monitoring capabilities:</p> <ol> <li>Asynchronous Cloning: Non-blocking clone operations that run in parallel</li> <li>Real-time Status Updates: Monitoring clone progress with detailed status information</li> <li>Progress Visualization: Rich terminal UI with progress bars and color coding</li> <li>Command-line Interface: Configuring clone operations via command-line arguments</li> <li>Error Handling: Properly handling and displaying errors during cloning</li> <li>Estimated Time Calculation: Providing estimates for remaining clone time</li> </ol>"},{"location":"examples/clone-monitoring/#running-the-example","title":"Running the Example","text":"<p>To run this example:</p> <ol> <li> <p>Install gitbench:    <pre><code>pip install gitbench\n</code></pre></p> </li> <li> <p>Optionally set GitHub credentials as environment variables:    <pre><code>export GITHUB_USERNAME=your-username\nexport GITHUB_TOKEN=your-personal-access-token\n</code></pre></p> </li> <li> <p>Run the example:    <pre><code>python examples/clone_monitoring.py\n</code></pre></p> </li> </ol> <p>Or specify custom repositories to clone:    <pre><code>python examples/clone_monitoring.py --repos https://github.com/user/repo1 https://github.com/user/repo2\n</code></pre></p>"},{"location":"examples/clone-monitoring/#how-it-works","title":"How It Works","text":""},{"location":"examples/clone-monitoring/#clone-status-monitoring","title":"Clone Status Monitoring","text":"<p>gitbench provides detailed status information for clone operations. Each clone task can have one of the following status types:</p> <ul> <li>queued: The repository is waiting to be cloned</li> <li>cloning: The repository is currently being cloned</li> <li>completed: The clone operation completed successfully</li> <li>failed: The clone operation failed (with error details)</li> </ul> <p>For repositories in the \"cloning\" state, gitbench provides progress information as a percentage.</p>"},{"location":"examples/clone-monitoring/#the-monitor-function","title":"The Monitor Function","text":"<p>The <code>monitor_clones</code> function is the heart of this example:</p> <ol> <li>It periodically fetches clone task status information</li> <li>Updates the terminal display with current progress</li> <li>Calculates estimated completion time based on progress rate</li> <li>Provides a summary of all repositories being cloned</li> <li>Exits when all clones are completed or the user interrupts</li> </ol>"},{"location":"examples/clone-monitoring/#terminal-ui","title":"Terminal UI","text":"<p>The example uses ANSI color codes to create a rich terminal UI:</p> <ul> <li>Green: Used for completed operations and positive progress</li> <li>Red: Used for errors and failed operations</li> <li>Yellow: Used for warnings and queued operations</li> <li>Blue: Used for active operations</li> </ul>"},{"location":"examples/clone-monitoring/#cross-platform-compatibility","title":"Cross-Platform Compatibility","text":"<p>The example includes accommodations for different operating systems:</p> <ul> <li>Terminal clearing works on both Unix-like systems and Windows</li> <li>ANSI color codes are disabled on Windows if not supported</li> </ul>"},{"location":"examples/clone-monitoring/#related-examples","title":"Related Examples","text":"<ul> <li>Basic Usage: Simpler example of gitbench's core functionality</li> <li>GitHub Client: Working with the GitHub API client</li> </ul>"},{"location":"examples/github-client/","title":"GitHub API Client Example","text":"<p>This example demonstrates how to use gitbench's GitHub API client to interact with GitHub repositories, users, and other resources. It covers authentication, fetching repository data, working with contributors, branches, and using Pydantic integration for data processing.</p>"},{"location":"examples/github-client/#code-example","title":"Code Example","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nGitHub API Client Example\n\nThis example demonstrates how to use the gitbench GitHub API client to:\n1. Create a GitHub client and validate credentials\n2. Fetch repositories for a user\n3. Get repository details\n4. List contributors and branches\n5. Convert the results to pandas DataFrames\n6. Check rate limits\n7. Use Pydantic model features for serialization\n\nOptional dependencies:\n- pandas: Required for DataFrame conversion (pip install pandas)\n  Install with: pip install \"gitbench[pandas]\"\n- pydantic: Required for model validation (pip install pydantic)\n  Install with: pip install \"gitbench[pydantic]\"\n\"\"\"\n\nimport os\nimport sys\nimport asyncio\nimport json\nfrom pprint import pprint\nfrom datetime import datetime\n\n# Add the parent directory to the Python path so we can import gitbench modules directly\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))\n\n# Direct imports from the project modules\nfrom gitbench.providers.github import GitHubClient\nfrom gitbench.utils.converters import to_dataframe, to_json\n\n\nasync def main():\n    # Get GitHub token from environment variable\n    github_token = os.environ.get(\"GITHUB_TOKEN\", \"\")\n\n    if not github_token:\n        print(\"\u26a0\ufe0f GitHub token not found in environment variables.\")\n        print(\"Set the GITHUB_TOKEN environment variable to use this example.\")\n        print(\"You can create a token at: https://github.com/settings/tokens\")\n        return\n\n    # Create a GitHub client\n    client = GitHubClient(token=github_token)\n\n    # Validate credentials\n    is_valid = await client.validate_credentials()\n    if not is_valid:\n        print(\"\u274c Invalid GitHub token\")\n        return\n\n    # Get authenticated user info\n    print(\"\\n\ud83e\uddd1\u200d\ud83d\udcbb Authenticated User Information:\")\n    user = await client.fetch_user_info()\n    print(f\"Authenticated as: {user.login} ({user.name})\")\n\n    # Check rate limits\n    print(\"\\n\ud83d\udcca API Rate Limits:\")\n    rate_limit = await client.get_rate_limit()\n    print(f\"Rate Limit: {rate_limit.remaining}/{rate_limit.limit} remaining\")\n    print(f\"Reset time: {rate_limit.reset_time}\")\n\n    # Get repositories for a user\n    username = \"octocat\"  # Example GitHub user\n    print(f\"\\n\ud83d\udcda Repositories for {username}:\")\n    repos = await client.fetch_repositories(username)\n\n    # Print repository information\n    print(f\"Found {len(repos)} repositories:\")\n    for i, repo in enumerate(repos[:5], 1):  # Print just the first 5\n        print(f\"  {i}. {repo.full_name} - {repo.description or 'No description'}\")\n        print(f\"     \u21b3 {repo.stargazers_count} stars, {repo.forks_count} forks, {repo.language or 'No language'}\")\n\n    if len(repos) &gt; 5:\n        print(f\"  ... and {len(repos) - 5} more repositories\")\n\n    if repos:\n        # Get detailed information about the first repository\n        repo = repos[0]\n        print(f\"\\n\ud83d\udcd6 Details for {repo.full_name}:\")\n        repo_details = await client.fetch_repository_details(username, repo.name)\n\n        # Print detailed information\n        print(f\"  Description: {repo_details.description or 'None'}\")\n        print(f\"  Language: {repo_details.language or 'None'}\")\n        print(f\"  Stars: {repo_details.stargazers_count}\")\n        print(f\"  Forks: {repo_details.forks_count}\")\n        print(f\"  Default Branch: {repo_details.default_branch}\")\n\n        # Get contributors\n        print(f\"\\n\ud83d\udc65 Top Contributors:\")\n        contributors = await client.fetch_contributors(username, repo.name)\n        for i, contributor in enumerate(contributors[:5], 1):  # Show top 5\n            print(f\"  {i}. {contributor.login} - {contributor.contributions} contributions\")\n\n        if len(contributors) &gt; 5:\n            print(f\"  ... and {len(contributors) - 5} more contributors\")\n\n        # Get branches\n        print(f\"\\n\ud83c\udf3f Branches:\")\n        branches = await client.fetch_branches(username, repo.name)\n        for i, branch in enumerate(branches[:5], 1):  # Show first 5\n            protected = \"\ud83d\udd12 Protected\" if branch.protected else \"\ud83d\udd13 Not protected\"\n            print(f\"  {i}. {branch.name} - {protected}\")\n\n        if len(branches) &gt; 5:\n            print(f\"  ... and {len(branches) - 5} more branches\")\n\n        # Convert to pandas DataFrame (if pandas is installed)\n        try:\n            print(\"\\n\ud83d\udcca Converting repositories to pandas DataFrame:\")\n            df = to_dataframe(repos)\n            print(f\"  DataFrame shape: {df.shape}\")\n            print(\"  Columns:\", \", \".join(list(df.columns)[:10]) + \"...\")\n            print(\"\\n  Sample data:\")\n            print(df[[\"name\", \"full_name\", \"stargazers_count\"]].head())\n        except ImportError:\n            print(\"  pandas not installed. Install with: pip install pandas\")\n\n        # Demonstrate Pydantic model features\n        print(\"\\n\ud83d\udd04 Pydantic Model Features:\")\n        if repos:\n            repo = repos[0]\n\n            # Use model_dump() to convert to dict\n            print(\"  Model to dict:\")\n            repo_dict = repo.model_dump()\n            print(f\"  \u21b3 {list(repo_dict.keys())[:5]}...\")\n\n            # Use model_dump_json() to convert directly to JSON\n            print(\"\\n  Model to JSON:\")\n            repo_json = repo.model_dump_json(indent=2)\n            print(f\"  \u21b3 First 100 chars: {repo_json[:100]}...\")\n\n            # Use datetime conversion methods\n            if repo.created_at:\n                print(\"\\n  Date/time helpers:\")\n                created_dt = repo.created_datetime()\n                if created_dt:\n                    print(f\"  \u21b3 Created: {created_dt.strftime('%Y-%m-%d %H:%M:%S')}\")\n                    days_since = (datetime.now() - created_dt).days\n                    print(f\"  \u21b3 Age: {days_since} days\")\n\n            # Show serialization with utility functions\n            print(\"\\n  Using to_json utility:\")\n            json_str = to_json(repo, indent=None)\n            print(f\"  \u21b3 {json_str[:100]}...\")\n\n\nif __name__ == \"__main__\":\n    # Run the async main function\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/github-client/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<p>This example demonstrates the following key features of gitbench's GitHub client:</p> <ol> <li>Authentication: Setting up a GitHub client with a token and validating credentials</li> <li>Repository Data: Fetching repositories, repository details, contributors, and branches</li> <li>Rate Limit Management: Checking and managing GitHub API rate limits</li> <li>Pydantic Integration: Utilizing Pydantic models for data serialization and validation</li> <li>Data Conversion: Converting API responses to pandas DataFrames and JSON</li> <li>Error Handling: Proper error checking and handling of API responses</li> </ol>"},{"location":"examples/github-client/#running-the-example","title":"Running the Example","text":"<p>To run this example:</p> <ol> <li> <p>Install gitbench with optional dependencies:    <pre><code>pip install \"gitbench[pandas,pydantic]\"\n</code></pre></p> </li> <li> <p>Set your GitHub token as an environment variable:    <pre><code>export GITHUB_TOKEN=your-personal-access-token\n</code></pre></p> </li> <li> <p>Run the example:    <pre><code>python examples/github_client.py\n</code></pre></p> </li> </ol>"},{"location":"examples/github-client/#github-api-features","title":"GitHub API Features","text":"<p>The gitbench GitHub client provides access to many GitHub API endpoints, including:</p> <ul> <li>Users: Get user information, repositories, and organizations</li> <li>Repositories: Get repository details, contents, and statistics</li> <li>Branches and Commits: List branches, get commit history</li> <li>Contributors: Get repository contributors and their statistics</li> <li>Issues and Pull Requests: Work with issues and pull requests</li> <li>Rate Limits: Check and manage API rate limits</li> </ul>"},{"location":"examples/github-client/#data-models","title":"Data Models","text":"<p>All GitHub API responses are converted to Pydantic models, providing:</p> <ul> <li>Type Validation: Ensure data types are correct</li> <li>Data Access: Convenient attribute access to API data</li> <li>Serialization: Easy conversion to JSON, dictionaries, or DataFrames</li> <li>DateTime Parsing: Convenience methods for working with dates and times</li> </ul>"},{"location":"examples/github-client/#related-examples","title":"Related Examples","text":"<ul> <li>Token Manager: Advanced token management for GitHub API</li> <li>Basic Usage: Core gitbench usage including repository operations</li> </ul>"},{"location":"examples/pydantic-repo-manager/","title":"Pydantic Integration Example","text":"<p>This example demonstrates how to use gitbench's Pydantic integration for enhanced type safety, validation, and serialization capabilities. The example shows how to use Pydantic models with gitbench's <code>RepoManager</code>, <code>CloneStatus</code>, and <code>CloneTask</code> classes.</p>"},{"location":"examples/pydantic-repo-manager/#code-example","title":"Code Example","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nPydantic-enabled RepoManager Example\n\nThis example demonstrates how to use the Pydantic models with the Rust-based RepoManager:\n1. Use the Pydantic wrappers for RepoManager, CloneStatus, and CloneTask\n2. Show serialization and validation of the models\n3. Convert between Rust objects and Pydantic models\n\nOptional dependencies:\n- pydantic: Required for Pydantic models (pip install pydantic)\n  Install with: pip install \"gitbench[pydantic]\"\n\"\"\"\n\nimport os\nimport sys\nimport json\nimport asyncio\nfrom pprint import pprint\nfrom datetime import datetime\n\n# Add the parent directory to the Python path so we can import gitbench modules directly\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))\n\n# Import the Pydantic-enabled models\nfrom gitbench.models.repo import (\n    RepoManager, CloneStatus, CloneTask, CloneStatusType,\n    clone_status_to_pydantic, clone_task_to_pydantic\n)\n\n\nasync def main():\n    # Get GitHub token from environment variable\n    github_token = os.environ.get(\"GITHUB_TOKEN\", \"\")\n\n    if not github_token:\n        print(\"\u26a0\ufe0f GitHub token not found in environment variables.\")\n        print(\"Set the GITHUB_TOKEN environment variable to use this example.\")\n        print(\"You can create a token at: https://github.com/settings/tokens\")\n        return\n\n    try:\n        # Create a repository URL to clone (public repository for example)\n        repo_url = \"https://github.com/octocat/Hello-World.git\"\n        urls = [repo_url]\n\n        # Create a RepoManager using the Pydantic wrapper\n        print(\"\\n\ud83d\udd27 Creating RepoManager with Pydantic support\")\n        manager = RepoManager(urls, \"username\", github_token)\n\n        # Start cloning the repository\n        print(\"\\n\ud83d\udd04 Cloning the repository\")\n        await manager.clone_all()\n\n        # Get the clone tasks and demonstrate Pydantic model features\n        print(\"\\n\ud83d\udccb Checking clone tasks\")\n        tasks = await manager.fetch_clone_tasks()\n\n        # Use Pydantic serialization features\n        for url, task in tasks.items():\n            print(f\"\\n\ud83d\udce6 Repository: {url}\")\n\n            # Show the task status\n            status = task.status\n            print(f\"  Status: {status.status_type}\")\n            if status.status_type == CloneStatusType.CLONING:\n                print(f\"  Progress: {status.progress}%\")\n            elif status.status_type == CloneStatusType.FAILED:\n                print(f\"  Error: {status.error}\")\n            elif status.status_type == CloneStatusType.COMPLETED:\n                print(f\"  Temp directory: {task.temp_dir}\")\n\n            # Demonstrate Pydantic model serialization\n            print(\"\\n  Pydantic Model Features:\")\n\n            # Convert to dict\n            task_dict = task.model_dump()\n            print(f\"  \u21b3 model_dump(): {list(task_dict.keys())}\")\n\n            # Convert to JSON\n            task_json = task.model_dump_json(indent=2)\n            print(f\"  \u21b3 model_dump_json():\")\n            pretty_json = json.dumps(json.loads(task_json), indent=4)\n            for line in pretty_json.split('\\n')[:7]:\n                print(f\"    {line}\")\n            print(\"    ...\")\n\n            # Validate from Python dict\n            print(\"\\n  Validation Features:\")\n            try:\n                # Create a CloneStatus from basic Python types\n                new_status = CloneStatus(\n                    status_type=CloneStatusType.COMPLETED,\n                    progress=None,\n                    error=None\n                )\n                print(f\"  \u21b3 Created new status: {new_status.status_type}\")\n\n                # Create a CloneTask with validation\n                new_task = CloneTask(\n                    url=\"https://github.com/example/repo.git\",\n                    status=new_status,\n                    temp_dir=\"/tmp/example\"\n                )\n                print(f\"  \u21b3 Created new task: {new_task.url}\")\n\n                # Show validation error handling\n                print(\"\\n  Validation Error Handling:\")\n                try:\n                    # This will fail validation - invalid status_type\n                    invalid_status = CloneStatus(\n                        status_type=\"invalid_status\",\n                        progress=None,\n                        error=None\n                    )\n                except Exception as e:\n                    print(f\"  \u21b3 Caught validation error: {str(e)[:100]}...\")\n\n            except Exception as e:\n                print(f\"  \u21b3 Error: {str(e)}\")\n\n        # Cleanup temp directories\n        print(\"\\n\ud83e\uddf9 Cleaning up temporary directories\")\n        cleanup_results = manager.cleanup()\n        for url, result in cleanup_results.items():\n            print(f\"  {url}: {'Success' if result is True else result}\")\n\n    except ImportError as e:\n        print(f\"\\n\u274c Error: {str(e)}\")\n        print(\"This example requires the Rust extension to be built.\")\n        print(\"Build it with: maturin develop\")\n    except Exception as e:\n        print(f\"\\n\u274c Error: {str(e)}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/pydantic-repo-manager/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<p>This example demonstrates several key features of gitbench's Pydantic integration:</p> <ol> <li>Pydantic Models: Using Pydantic models for gitbench's core classes</li> <li>Type Validation: Automatic validation of data types and values</li> <li>Serialization: Converting models to dictionaries and JSON</li> <li>Error Handling: Catching and handling validation errors</li> <li>Enum Support: Using enums for status types with validation</li> <li>Data Creation: Creating new model instances with validation</li> </ol>"},{"location":"examples/pydantic-repo-manager/#pydantic-integration","title":"Pydantic Integration","text":"<p>gitbench provides Pydantic-enabled versions of its core classes:</p> Core Type Pydantic Model <code>RustRepoManager</code> <code>RepoManager</code> <code>RustCloneTask</code> <code>CloneTask</code> <code>RustCloneStatus</code> <code>CloneStatus</code> <p>These models provide the same functionality as the core types, with the added benefits of Pydantic's validation and serialization capabilities.</p>"},{"location":"examples/pydantic-repo-manager/#model-validation","title":"Model Validation","text":"<p>Pydantic models provide automatic validation of data:</p> <pre><code># This will work - valid status type\nvalid_status = CloneStatus(\n    status_type=CloneStatusType.COMPLETED,\n    progress=None,\n    error=None\n)\n\n# This will raise a validation error - invalid status type\ntry:\n    invalid_status = CloneStatus(\n        status_type=\"invalid_status\",  # Not a valid CloneStatusType\n        progress=None,\n        error=None\n    )\nexcept ValidationError as e:\n    print(f\"Validation error: {e}\")\n</code></pre>"},{"location":"examples/pydantic-repo-manager/#serialization","title":"Serialization","text":"<p>Pydantic models provide easy serialization to dictionaries and JSON:</p> <pre><code># Convert to dict\ntask_dict = task.model_dump()\n\n# Convert to JSON string\ntask_json = task.model_dump_json(indent=2)\n\n# Convert to JSON with custom options\ntask_json = task.model_dump_json(\n    indent=2,\n    exclude={\"status.error\"},  # Exclude specific fields\n    include={\"url\", \"status.status_type\"}  # Include only specific fields\n)\n</code></pre>"},{"location":"examples/pydantic-repo-manager/#running-the-example","title":"Running the Example","text":"<p>To run this example:</p> <ol> <li> <p>Install gitbench with pydantic support:    <pre><code>pip install \"gitbench[pydantic]\"\n</code></pre></p> </li> <li> <p>Set your GitHub token as an environment variable:    <pre><code>export GITHUB_TOKEN=your-personal-access-token\n</code></pre></p> </li> <li> <p>Run the example:    <pre><code>python examples/pydantic_repo_manager.py\n</code></pre></p> </li> </ol>"},{"location":"examples/pydantic-repo-manager/#conversion-functions","title":"Conversion Functions","text":"<p>gitbench provides utility functions to convert between Rust types and Pydantic models:</p> <pre><code># Convert from Rust type to Pydantic model\nfrom gitbench.models.repo import clone_status_to_pydantic, clone_task_to_pydantic\n\n# Get a Rust clone task from the repo manager\nrust_task = repo_manager.get_clone_task(url)\n\n# Convert to Pydantic model\npydantic_task = clone_task_to_pydantic(rust_task)\n</code></pre>"},{"location":"examples/pydantic-repo-manager/#enum-types","title":"Enum Types","text":"<p>gitbench provides Pydantic-compatible enums for various types:</p> <pre><code>from gitbench.models.repo import CloneStatusType\n\n# Available status types\nCloneStatusType.QUEUED     # Repository is queued for cloning\nCloneStatusType.CLONING    # Repository is currently being cloned\nCloneStatusType.COMPLETED  # Clone operation completed successfully\nCloneStatusType.FAILED     # Clone operation failed\n</code></pre> <p>These enums provide type safety and auto-completion in supported IDEs.</p>"},{"location":"examples/pydantic-repo-manager/#advanced-usage","title":"Advanced Usage","text":""},{"location":"examples/pydantic-repo-manager/#custom-validation","title":"Custom Validation","text":"<p>You can extend gitbench's Pydantic models with custom validation:</p> <pre><code>from pydantic import validator\nfrom gitbench.models.repo import CloneTask\n\nclass CustomCloneTask(CloneTask):\n    @validator('url')\n    def validate_url(cls, v):\n        if not v.startswith('https://'):\n            raise ValueError('URL must use HTTPS protocol')\n        return v\n</code></pre>"},{"location":"examples/pydantic-repo-manager/#integration-with-other-systems","title":"Integration with Other Systems","text":"<p>Pydantic models make it easy to integrate gitbench with web frameworks and APIs:</p> <pre><code># FastAPI example\nfrom fastapi import FastAPI\nfrom gitbench.models.repo import CloneTask\n\napp = FastAPI()\n\n@app.post(\"/clone\")\nasync def clone_repository(task: CloneTask):\n    # Process the validated task\n    # ...\n    return {\"status\": \"success\"}\n</code></pre>"},{"location":"examples/pydantic-repo-manager/#related-examples","title":"Related Examples","text":"<ul> <li>GitHub Client: Working with the GitHub API client</li> <li>Basic Usage: Core gitbench usage without Pydantic</li> </ul>"},{"location":"examples/secure-credentials/","title":"Secure Credentials Example","text":"<p>This example demonstrates how to use gitbench's <code>CredentialManager</code> to securely store and retrieve authentication tokens and credentials. It covers different encryption methods, from simple base64 encoding to AES encryption and password-derived keys.</p>"},{"location":"examples/secure-credentials/#code-example","title":"Code Example","text":"<pre><code>\"\"\"\nExample of using secure token encryption with CredentialManager.\n\nThis example demonstrates various ways to use the CredentialManager:\n1. Basic usage with default settings (base64 encoding only)\n2. Using AES-GCM encryption with a provided key\n3. Using a password-derived key\n4. Using custom encryption functions\n\nNote: This is just an example. In a real application, never hardcode passwords\nand properly manage encryption keys.\n\"\"\"\n\nimport os\nfrom getpass import getpass\n\nfrom gitbench.providers.base import ProviderType\nfrom gitbench.utils.auth import CredentialManager, derive_key_from_password\n\n\ndef basic_example():\n    \"\"\"Basic usage of CredentialManager (with warning about weak security).\"\"\"\n    # This will show a warning about using base64 encoding only\n    manager = CredentialManager()\n\n    # Save a credential\n    manager.save_credential(\n        provider=ProviderType.GITHUB, token=\"github_token_123\", username=\"example_user\"\n    )\n\n    # Get credentials\n    credentials = manager.get_credentials(ProviderType.GITHUB)\n    print(f\"Retrieved {len(credentials)} credentials\")\n    for cred in credentials:\n        print(f\"Username: {cred.username}, Token: {cred.token}\")\n\n    # Clean up\n    manager.clear_credentials()\n\n\ndef aes_example():\n    \"\"\"Example using AES-GCM encryption with a generated key.\"\"\"\n    # Generate a random 32-byte key (AES-256)\n    key = os.urandom(32)\n    print(f\"Generated key: {key.hex()}\")\n\n    # Create a manager with AES encryption\n    manager = CredentialManager(encryption_key=key)\n\n    # Save a credential\n    manager.save_credential(\n        provider=ProviderType.GITHUB, token=\"github_token_456\", username=\"secure_user\"\n    )\n\n    # Get credentials\n    credentials = manager.get_credentials(ProviderType.GITHUB)\n    print(f\"Retrieved {len(credentials)} credentials\")\n    for cred in credentials:\n        print(f\"Username: {cred.username}, Token: {cred.token}\")\n\n    # Clean up\n    manager.clear_credentials()\n\n    print(\"\\nIn a real application, you would need to securely store this key\")\n    print(\"and provide it each time you create the CredentialManager.\")\n\n\ndef password_example():\n    \"\"\"Example using a password-derived key with salt.\"\"\"\n    # Path to store the salt\n    salt_file = \"~/.gitbench/salt.bin\"\n\n    # In a real application, you would prompt for the password securely\n    # password = getpass(\"Enter your password: \")\n    password = \"secure_password_example\"  # Don't do this in real code!\n\n    # Create a manager from password (this will generate and save the salt)\n    manager = CredentialManager.from_password(password=password, salt_file=salt_file)\n\n    # Save a credential\n    manager.save_credential(\n        provider=ProviderType.GITHUB,\n        token=\"github_token_789\",\n        username=\"password_protected_user\",\n    )\n\n    # Get credentials\n    credentials = manager.get_credentials(ProviderType.GITHUB)\n    print(f\"Retrieved {len(credentials)} credentials\")\n    for cred in credentials:\n        print(f\"Username: {cred.username}, Token: {cred.token}\")\n\n    # Clean up\n    manager.clear_credentials()\n\n    print(\"\\nThe salt was saved to:\", os.path.expanduser(salt_file))\n    print(\"To access the same encrypted data, you would need both the password\")\n    print(\"and the salt file.\")\n\n\ndef custom_encryption_example():\n    \"\"\"Example using custom encryption functions.\"\"\"\n\n    # Define custom encryption functions (very basic, don't use in real applications)\n    def custom_encrypt(token: str) -&gt; str:\n        # Just a simple XOR with a fixed key (NOT secure!)\n        key = \"SECRETKEY\"\n        result = \"\"\n        for i, char in enumerate(token):\n            key_char = key[i % len(key)]\n            result += chr(ord(char) ^ ord(key_char))\n        return base64.b64encode(result.encode()).decode()\n\n    def custom_decrypt(encrypted_token: str) -&gt; str:\n        # Reverse the XOR operation\n        key = \"SECRETKEY\"\n        token = base64.b64decode(encrypted_token.encode()).decode()\n        result = \"\"\n        for i, char in enumerate(token):\n            key_char = key[i % len(key)]\n            result += chr(ord(char) ^ ord(key_char))\n        return result\n\n    # Create manager with custom encryption\n    manager = CredentialManager(\n        encrypt_func=custom_encrypt, decrypt_func=custom_decrypt\n    )\n\n    # Save a credential\n    manager.save_credential(\n        provider=ProviderType.GITHUB,\n        token=\"github_token_custom\",\n        username=\"custom_encryption_user\",\n    )\n\n    # Get credentials\n    credentials = manager.get_credentials(ProviderType.GITHUB)\n    print(f\"Retrieved {len(credentials)} credentials\")\n    for cred in credentials:\n        print(f\"Username: {cred.username}, Token: {cred.token}\")\n\n    # Clean up\n    manager.clear_credentials()\n\n    print(\"\\nThis example shows how to provide your own encryption functions.\")\n    print(\"In a real application, you would use a strong encryption algorithm\")\n    print(\"and proper key management.\")\n\n\nif __name__ == \"__main__\":\n    # Add import here to avoid issues with the custom encryption example\n    import base64\n\n    print(\"\\n=== Basic Example (base64 encoding only) ===\")\n    basic_example()\n\n    try:\n        print(\"\\n=== AES-GCM Encryption Example ===\")\n        aes_example()\n\n        print(\"\\n=== Password-Based Encryption Example ===\")\n        password_example()\n    except ImportError:\n        print(\"\\nAES examples require the 'cryptography' package.\")\n        print(\"Install it with: pip install cryptography\")\n\n    print(\"\\n=== Custom Encryption Example ===\")\n    custom_encryption_example()\n</code></pre>"},{"location":"examples/secure-credentials/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<p>This example demonstrates several secure credential management approaches:</p> <ol> <li>Basic Usage: Simple base64 encoding for token storage (minimal security)</li> <li>AES Encryption: Using AES-GCM encryption with a randomly generated key</li> <li>Password-Based Encryption: Deriving an encryption key from a password using PBKDF2</li> <li>Custom Encryption: Implementing your own encryption and decryption functions</li> <li>Multi-Provider Support: Storing and retrieving credentials for different providers</li> </ol>"},{"location":"examples/secure-credentials/#security-approaches","title":"Security Approaches","text":""},{"location":"examples/secure-credentials/#base64-encoding-minimal-security","title":"Base64 Encoding (Minimal Security)","text":"<p>The most basic approach uses simple base64 encoding:</p> <pre><code>manager = CredentialManager()  # No encryption key provided\n</code></pre> <p>This provides minimal security (obfuscation only) and is not recommended for production use.</p>"},{"location":"examples/secure-credentials/#aes-gcm-encryption-recommended","title":"AES-GCM Encryption (Recommended)","text":"<p>For strong security, use AES-GCM encryption with a randomly generated key:</p> <pre><code># Generate a secure random key\nkey = os.urandom(32)  # 256 bits\n\n# Create manager with AES encryption\nmanager = CredentialManager(encryption_key=key)\n</code></pre> <p>The challenge with this approach is securely storing the encryption key.</p>"},{"location":"examples/secure-credentials/#password-based-key-derivation-user-friendly","title":"Password-Based Key Derivation (User-Friendly)","text":"<p>For user-friendly security, derive an encryption key from a password:</p> <pre><code># Create a manager using a password\nmanager = CredentialManager.from_password(\n    password=\"user_password\", \n    salt_file=\"~/.gitfleet/salt.bin\"\n)\n</code></pre> <p>This approach uses PBKDF2 with a salt to derive a secure encryption key.</p>"},{"location":"examples/secure-credentials/#custom-encryption-advanced","title":"Custom Encryption (Advanced)","text":"<p>For specialized needs, you can provide custom encryption and decryption functions:</p> <pre><code>manager = CredentialManager(\n    encrypt_func=my_encrypt_function,\n    decrypt_func=my_decrypt_function\n)\n</code></pre> <p>This allows integration with hardware security modules or other encryption systems.</p>"},{"location":"examples/secure-credentials/#running-the-example","title":"Running the Example","text":"<p>To run this example:</p> <ol> <li> <p>Install gitbench with crypto support:    <pre><code>pip install \"gitbench[crypto]\"\n</code></pre></p> </li> <li> <p>Run the example:    <pre><code>python examples/secure_credentials.py\n</code></pre></p> </li> </ol>"},{"location":"examples/secure-credentials/#implementation-details","title":"Implementation Details","text":""},{"location":"examples/secure-credentials/#credentialmanager-class","title":"CredentialManager Class","text":"<p>The <code>CredentialManager</code> class provides the following methods:</p> <ul> <li>save_credential: Store a credential for a specific provider</li> <li>get_credentials: Retrieve all credentials for a provider</li> <li>clear_credentials: Remove all stored credentials</li> <li>from_password: Class method to create a manager with password-based encryption</li> </ul>"},{"location":"examples/secure-credentials/#provider-types","title":"Provider Types","text":"<p>gitbench supports different credential provider types:</p> <pre><code>from gitbench.providers.base import ProviderType\n\n# Available provider types\nProviderType.GITHUB    # GitHub credentials\nProviderType.GITLAB    # GitLab credentials\nProviderType.BITBUCKET # Bitbucket credentials\n</code></pre>"},{"location":"examples/secure-credentials/#encryption-methods","title":"Encryption Methods","text":"<p>The encryption methods used in gitbench are:</p> <ol> <li>Base64: Simple encoding with no cryptographic security</li> <li>AES-GCM: Authenticated encryption with associated data (AEAD)</li> <li>PBKDF2: Password-based key derivation for generating encryption keys</li> </ol>"},{"location":"examples/secure-credentials/#security-best-practices","title":"Security Best Practices","text":"<p>When using <code>CredentialManager</code> in production:</p> <ol> <li>Never hardcode passwords or keys in your application code</li> <li>Use environment variables or secure credential stores for sensitive information</li> <li>Always use AES encryption or stronger when handling authentication tokens</li> <li>Set appropriate file permissions for salt and credential storage files</li> <li>Consider using a vault service like HashiCorp Vault for enterprise applications</li> </ol>"},{"location":"examples/secure-credentials/#related-examples","title":"Related Examples","text":"<ul> <li>Token Manager: Multi-token management for API rate limiting</li> <li>GitHub Client: Using authentication with the GitHub API client</li> </ul>"},{"location":"examples/token-manager/","title":"Token Manager Example","text":"<p>This example demonstrates how to use gitbench's <code>TokenManager</code> to handle multiple authentication tokens for GitHub API operations. The token manager automatically rotates tokens when rate limits are reached, ensuring your application can continue making API requests without interruption.</p>"},{"location":"examples/token-manager/#code-example","title":"Code Example","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nToken Manager Example\n\nThis example demonstrates how to use multiple tokens with the gitbench library\nto handle rate limiting across different API providers.\n\nOptional dependencies:\n- cryptography: For secure token encryption (pip install cryptography)\n  Install with: pip install \"gitbench[crypto]\"\n\"\"\"\n\nimport os\nimport asyncio\nimport time\nfrom pprint import pprint\n\nfrom gitbench import GitHubClient\nfrom gitbench.providers import TokenManager, TokenStatus, ProviderType\n\n\nasync def main():\n    # Get GitHub tokens from environment variables\n    # Format: TOKEN1,TOKEN2,TOKEN3\n    github_tokens = os.environ.get(\"GITHUB_TOKENS\", \"\").split(\",\")\n\n    if not github_tokens or not github_tokens[0]:\n        # Fall back to single token\n        github_tokens = [os.environ.get(\"GITHUB_TOKEN\", \"\")]\n        if not github_tokens[0]:\n            print(\"\u26a0\ufe0f No GitHub tokens found in environment variables.\")\n            print(\"Set the GITHUB_TOKENS or GITHUB_TOKEN environment variable to use this example.\")\n            return\n\n    print(f\"Using {len(github_tokens)} GitHub token(s)\")\n\n    # Create a token manager and add tokens\n    token_manager = TokenManager()\n    for token in github_tokens:\n        token_manager.add_token(token, ProviderType.GITHUB)\n\n    # Create a single client with token manager for auto-rotation\n    github = GitHubClient(\n        token=github_tokens[0],  # Use first token as default\n        token_manager=token_manager  # Token manager for rotation\n    )\n\n    # Check rate limits for all tokens\n    print(\"\\n\ud83d\udcca API Rate Limits for all tokens:\")\n    all_tokens = token_manager.get_all_tokens(ProviderType.GITHUB)\n\n    # First fetch the rate limits to populate token information\n    try:\n        await github.get_rate_limit()\n    except Exception as e:\n        print(f\"Error fetching initial rate limit: {e}\")\n\n    # Display token information\n    for i, token_info in enumerate(all_tokens, 1):\n        if hasattr(token_info, \"rate_limit\") and token_info.rate_limit:\n            rl = token_info.rate_limit\n            print(f\"Token {i}: {rl.remaining}/{rl.limit} requests remaining\")\n            print(f\"       Resets at: {time.ctime(rl.reset_time)}\")\n            print(f\"       Status: {token_info.status}\")\n        else:\n            print(f\"Token {i}: Rate limit info not yet fetched\")\n\n    # Function to demonstrate using token manager with automatic rotation\n    async def fetch_repositories_with_token_manager(owners):\n        print(f\"\\n\ud83d\udcda Fetching repositories for {len(owners)} users:\")\n\n        results = {}\n\n        for owner in owners:\n            try:\n                print(f\"Fetching repos for {owner} (token manager will auto-select token)\")\n                repos = await github.fetch_repositories(owner)\n                results[owner] = repos\n                print(f\"  \u2705 Found {len(repos)} repositories for {owner}\")\n\n                # Check how many tokens are still available\n                available = token_manager.count_available_tokens(ProviderType.GITHUB)\n                print(f\"  \ud83d\udcca {available}/{len(all_tokens)} tokens available\")\n\n            except Exception as e:\n                print(f\"  \u274c Error fetching repos for {owner}: {e}\")\n                print(f\"  \u2139\ufe0f All tokens may be rate limited or invalid\")\n\n        return results\n\n    # Test with multiple users\n    sample_users = [\"octocat\", \"torvalds\", \"gvanrossum\", \"kennethreitz\", \"yyx990803\"]\n\n    print(\"\\n\ud83d\udd04 Using TokenManager for automatic token rotation:\")\n    repo_results = await fetch_repositories_with_token_manager(sample_users)\n\n    # Print summary of all repos found\n    print(\"\\n\ud83d\udccb Summary:\")\n    total_repos = sum(len(repos) for repos in repo_results.values())\n    print(f\"Total repositories found: {total_repos}\")\n    for owner, repos in repo_results.items():\n        print(f\"  {owner}: {len(repos)} repositories\")\n\n    # Final token status\n    print(\"\\n\ud83d\udcca Final token status:\")\n    for i, token_info in enumerate(token_manager.get_all_tokens(ProviderType.GITHUB), 1):\n        status = \"Available\"\n        if hasattr(token_info, \"status\"):\n            if token_info.status == TokenStatus.RATE_LIMITED and hasattr(token_info, \"rate_limit\"):\n                reset_time = token_info.rate_limit.reset_time if token_info.rate_limit else 0\n                status = f\"Rate limited (resets at {time.ctime(reset_time)})\"\n            elif token_info.status == TokenStatus.INVALID:\n                status = \"Invalid\"\n        print(f\"Token {i}: {status}\")\n\n\nif __name__ == \"__main__\":\n    # Set up the event loop and run the main async function\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/token-manager/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<p>This example demonstrates several key features of gitbench's token management capabilities:</p> <ol> <li>Multiple Token Management: Managing and tracking multiple API tokens</li> <li>Automatic Token Rotation: Switching to a different token when rate limits are reached</li> <li>Rate Limit Monitoring: Checking and displaying rate limit information for each token</li> <li>Token Status Tracking: Monitoring the status of each token (available, rate limited, invalid)</li> <li>Exception Handling: Properly handling API rate limit and authentication exceptions</li> </ol>"},{"location":"examples/token-manager/#token-manager-architecture","title":"Token Manager Architecture","text":"<p>gitbench's <code>TokenManager</code> is designed to solve the common problem of API rate limiting when working with GitHub and other Git hosting providers. The architecture includes:</p> <ol> <li>Token Collection: Store and manage multiple tokens per provider</li> <li>Rate Limit Tracking: Track remaining API calls for each token</li> <li>Reset Time Monitoring: Record when rate limits will reset</li> <li>Status Classification: Categorize tokens as available, rate limited, or invalid</li> <li>Automatic Selection: Choose the best available token for each request</li> </ol>"},{"location":"examples/token-manager/#token-status-types","title":"Token Status Types","text":"<p>The <code>TokenManager</code> tracks the following status types for each token:</p> <ul> <li>AVAILABLE: The token is valid and has remaining API calls</li> <li>RATE_LIMITED: The token has reached its API rate limit</li> <li>INVALID: The token is invalid or has been revoked</li> </ul>"},{"location":"examples/token-manager/#running-the-example","title":"Running the Example","text":"<p>To run this example:</p> <ol> <li> <p>Install gitbench:    <pre><code>pip install gitbench\n</code></pre></p> </li> <li> <p>Set up multiple GitHub tokens as environment variables:    <pre><code># Option 1: Multiple tokens in a comma-separated list\nexport GITHUB_TOKENS=token1,token2,token3\n\n# Option 2: Single token\nexport GITHUB_TOKEN=your_github_token\n</code></pre></p> </li> <li> <p>Run the example:    <pre><code>python examples/token_manager.py\n</code></pre></p> </li> </ol>"},{"location":"examples/token-manager/#integration-with-api-clients","title":"Integration with API Clients","text":"<p>The token manager integrates seamlessly with gitbench's API clients:</p> <pre><code># Create a token manager\ntoken_manager = TokenManager()\nfor token in github_tokens:\n    token_manager.add_token(token, ProviderType.GITHUB)\n\n# Create a client with token manager\ngithub = GitHubClient(\n    token=github_tokens[0],  # Initial token\n    token_manager=token_manager  # For auto-rotation\n)\n\n# Now API calls will automatically use a different token when rate limits are reached\nrepos = await github.fetch_repositories(\"octocat\")\n</code></pre>"},{"location":"examples/token-manager/#best-practices-for-token-management","title":"Best Practices for Token Management","text":""},{"location":"examples/token-manager/#token-security","title":"Token Security","text":"<p>Always store tokens securely:</p> <pre><code>from gitbench.utils.auth import CredentialManager\n\n# Create a secure credential manager\ncredential_manager = CredentialManager.from_password(password=\"secure_password\")\n\n# Save tokens securely\nfor token in tokens:\n    credential_manager.save_credential(\n        provider=ProviderType.GITHUB,\n        token=token,\n        username=\"your_username\"\n    )\n</code></pre>"},{"location":"examples/token-manager/#token-rotation-strategies","title":"Token Rotation Strategies","text":"<p>Different strategies can be implemented for token rotation:</p> <ol> <li>Round-Robin: Cycle through tokens evenly</li> <li>Priority-Based: Use certain tokens before others</li> <li>Rate-Aware: Select tokens with the most remaining rate limit</li> </ol> <p>gitbench's <code>TokenManager</code> uses a rate-aware strategy by default.</p>"},{"location":"examples/token-manager/#handling-rate-limit-exhaustion","title":"Handling Rate Limit Exhaustion","text":"<p>When all tokens are rate-limited:</p> <pre><code>try:\n    repos = await github.fetch_repositories(\"octocat\")\nexcept RateLimitError as e:\n    # All tokens are rate limited\n    earliest_reset = token_manager.get_earliest_reset_time(ProviderType.GITHUB)\n    wait_seconds = earliest_reset - time.time()\n\n    if wait_seconds &gt; 0:\n        print(f\"All tokens rate limited. Waiting {wait_seconds} seconds...\")\n        await asyncio.sleep(wait_seconds)\n\n        # Try again after waiting\n        repos = await github.fetch_repositories(\"octocat\")\n</code></pre>"},{"location":"examples/token-manager/#related-examples","title":"Related Examples","text":"<ul> <li>Secure Credentials: Securely storing authentication tokens</li> <li>GitHub Client: Working with the GitHub API client</li> </ul>"},{"location":"examples/web-monitor/","title":"Web Monitoring Example","text":"<p>This example demonstrates how to create a simple web application for monitoring Git repository cloning operations. It uses FastAPI to provide a real-time web dashboard that displays clone status, progress, and repository information.</p>"},{"location":"examples/web-monitor/#code-example","title":"Code Example","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\ngitbench Web Monitor Example\n\nThis example demonstrates how to create a web-based dashboard for monitoring\nrepository cloning operations using gitbench and FastAPI.\n\nDependencies:\n- fastapi: Web framework for APIs (pip install fastapi)\n- uvicorn: ASGI server for FastAPI (pip install uvicorn)\n- jinja2: Template engine (pip install jinja2)\n\nInstall all with: pip install \"gitbench[web]\"\n\"\"\"\n\nimport os\nimport asyncio\nimport argparse\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\n\nimport uvicorn\nfrom fastapi import FastAPI, Request, WebSocket, WebSocketDisconnect\nfrom fastapi.responses import HTMLResponse\nfrom fastapi.staticfiles import StaticFiles\nfrom fastapi.templating import Jinja2Templates\n\nfrom gitbench import RepoManager\nfrom gitbench.models.repo import CloneTask\n\n\n# Create the FastAPI application\napp = FastAPI(title=\"gitbench Web Monitor\")\n\n# Create a directory for templates and static files\nos.makedirs(\"templates\", exist_ok=True)\nos.makedirs(\"static\", exist_ok=True)\n\n# Create a simple CSS file\ncss_content = \"\"\"\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    margin: 0;\n    padding: 20px;\n    background-color: #f8f9fa;\n    color: #333;\n}\n.container {\n    max-width: 1200px;\n    margin: 0 auto;\n}\nh1 {\n    color: #3f51b5;\n    border-bottom: 2px solid #3f51b5;\n    padding-bottom: 10px;\n}\n.dashboard {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));\n    gap: 20px;\n    margin-top: 20px;\n}\n.repo-card {\n    background-color: white;\n    border-radius: 8px;\n    box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n    padding: 15px;\n    transition: transform 0.2s;\n}\n.repo-card:hover {\n    transform: translateY(-5px);\n}\n.repo-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 10px;\n}\n.repo-title {\n    font-size: 1.2rem;\n    font-weight: bold;\n    color: #3f51b5;\n}\n.status {\n    padding: 5px 10px;\n    border-radius: 15px;\n    font-size: 0.8rem;\n    font-weight: bold;\n}\n.status-queued {\n    background-color: #ffd54f;\n    color: #7e6514;\n}\n.status-cloning {\n    background-color: #64b5f6;\n    color: #0d47a1;\n}\n.status-completed {\n    background-color: #a5d6a7;\n    color: #1b5e20;\n}\n.status-failed {\n    background-color: #ef9a9a;\n    color: #b71c1c;\n}\n.progress-bar {\n    height: 10px;\n    background-color: #e0e0e0;\n    border-radius: 5px;\n    margin: 10px 0;\n    overflow: hidden;\n}\n.progress-fill {\n    height: 100%;\n    background-color: #4caf50;\n    width: 0%;\n    transition: width 0.3s ease;\n}\n.details {\n    font-size: 0.9rem;\n    margin-top: 10px;\n    color: #666;\n}\n.error {\n    color: #d32f2f;\n    margin-top: 10px;\n    font-size: 0.9rem;\n    word-break: break-word;\n}\n.summary {\n    background-color: white;\n    border-radius: 8px;\n    box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n    padding: 15px;\n    margin-bottom: 20px;\n    display: flex;\n    justify-content: space-between;\n}\n.summary-item {\n    text-align: center;\n}\n.summary-value {\n    font-size: 2rem;\n    font-weight: bold;\n}\n.summary-label {\n    font-size: 0.9rem;\n    color: #666;\n}\n.queue { color: #ffa000; }\n.active { color: #1976d2; }\n.completed { color: #388e3c; }\n.failed { color: #d32f2f; }\n\"\"\"\n\n# Write CSS file\nwith open(\"static/style.css\", \"w\") as f:\n    f.write(css_content)\n\n# Create HTML template\ntemplate_content = \"\"\"\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;gitbench Monitor&lt;/title&gt;\n    &lt;link rel=\"stylesheet\" href=\"/static/style.css\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"container\"&gt;\n        &lt;h1&gt;gitbench Repository Clone Monitor&lt;/h1&gt;\n\n        &lt;div class=\"summary\"&gt;\n            &lt;div class=\"summary-item\"&gt;\n                &lt;div class=\"summary-value\" id=\"total-repos\"&gt;{{ tasks|length }}&lt;/div&gt;\n                &lt;div class=\"summary-label\"&gt;Total Repositories&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"summary-item\"&gt;\n                &lt;div class=\"summary-value queue\" id=\"queued-repos\"&gt;{{ queued }}&lt;/div&gt;\n                &lt;div class=\"summary-label\"&gt;Queued&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"summary-item\"&gt;\n                &lt;div class=\"summary-value active\" id=\"active-repos\"&gt;{{ active }}&lt;/div&gt;\n                &lt;div class=\"summary-label\"&gt;Active&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"summary-item\"&gt;\n                &lt;div class=\"summary-value completed\" id=\"completed-repos\"&gt;{{ completed }}&lt;/div&gt;\n                &lt;div class=\"summary-label\"&gt;Completed&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"summary-item\"&gt;\n                &lt;div class=\"summary-value failed\" id=\"failed-repos\"&gt;{{ failed }}&lt;/div&gt;\n                &lt;div class=\"summary-label\"&gt;Failed&lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;div class=\"dashboard\" id=\"dashboard\"&gt;\n            {% for url, task in tasks.items() %}\n            &lt;div class=\"repo-card\" id=\"repo-{{ loop.index }}\"&gt;\n                &lt;div class=\"repo-header\"&gt;\n                    &lt;div class=\"repo-title\"&gt;{{ url.split('/')[-1].replace('.git', '') }}&lt;/div&gt;\n                    &lt;div class=\"status status-{{ task.status.status_type }}\"&gt;{{ task.status.status_type|upper }}&lt;/div&gt;\n                &lt;/div&gt;\n                &lt;div&gt;{{ url }}&lt;/div&gt;\n\n                {% if task.status.status_type == \"cloning\" and task.status.progress is not none %}\n                &lt;div class=\"progress-bar\"&gt;\n                    &lt;div class=\"progress-fill\" style=\"width: {{ task.status.progress }}%\"&gt;&lt;/div&gt;\n                &lt;/div&gt;\n                &lt;div&gt;Progress: {{ task.status.progress }}%&lt;/div&gt;\n                {% endif %}\n\n                {% if task.status.status_type == \"failed\" and task.status.error %}\n                &lt;div class=\"error\"&gt;Error: {{ task.status.error }}&lt;/div&gt;\n                {% endif %}\n\n                {% if task.temp_dir %}\n                &lt;div class=\"details\"&gt;Directory: {{ task.temp_dir }}&lt;/div&gt;\n                {% endif %}\n            &lt;/div&gt;\n            {% endfor %}\n        &lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n        const ws = new WebSocket(`ws://${window.location.host}/ws`);\n\n        ws.onmessage = function(event) {\n            const data = JSON.parse(event.data);\n\n            // Update summary counts\n            document.getElementById('total-repos').textContent = Object.keys(data.tasks).length;\n            document.getElementById('queued-repos').textContent = data.summary.queued;\n            document.getElementById('active-repos').textContent = data.summary.active;\n            document.getElementById('completed-repos').textContent = data.summary.completed;\n            document.getElementById('failed-repos').textContent = data.summary.failed;\n\n            // Clear existing repos\n            const dashboard = document.getElementById('dashboard');\n            dashboard.innerHTML = '';\n\n            // Add repo cards\n            let index = 1;\n            for (const [url, task] of Object.entries(data.tasks)) {\n                const repoName = url.split('/').pop().replace('.git', '');\n                const statusType = task.status.status_type;\n\n                const card = document.createElement('div');\n                card.className = 'repo-card';\n                card.id = `repo-${index}`;\n\n                let cardContent = `\n                    &lt;div class=\"repo-header\"&gt;\n                        &lt;div class=\"repo-title\"&gt;${repoName}&lt;/div&gt;\n                        &lt;div class=\"status status-${statusType}\"&gt;${statusType.toUpperCase()}&lt;/div&gt;\n                    &lt;/div&gt;\n                    &lt;div&gt;${url}&lt;/div&gt;\n                `;\n\n                if (statusType === 'cloning' &amp;&amp; task.status.progress !== null) {\n                    cardContent += `\n                        &lt;div class=\"progress-bar\"&gt;\n                            &lt;div class=\"progress-fill\" style=\"width: ${task.status.progress}%\"&gt;&lt;/div&gt;\n                        &lt;/div&gt;\n                        &lt;div&gt;Progress: ${task.status.progress}%&lt;/div&gt;\n                    `;\n                }\n\n                if (statusType === 'failed' &amp;&amp; task.status.error) {\n                    cardContent += `\n                        &lt;div class=\"error\"&gt;Error: ${task.status.error}&lt;/div&gt;\n                    `;\n                }\n\n                if (task.temp_dir) {\n                    cardContent += `\n                        &lt;div class=\"details\"&gt;Directory: ${task.temp_dir}&lt;/div&gt;\n                    `;\n                }\n\n                card.innerHTML = cardContent;\n                dashboard.appendChild(card);\n                index++;\n            }\n        };\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n\n# Write template file\nwith open(\"templates/index.html\", \"w\") as f:\n    f.write(template_content)\n\n# Set up templates and static files\ntemplates = Jinja2Templates(directory=\"templates\")\napp.mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\")\n\n# Store global state\nclass AppState:\n    def __init__(self):\n        self.repo_manager: Optional[RepoManager] = None\n        self.clone_future = None\n        self.active_connections: List[WebSocket] = []\n        self.monitor_task = None\n        self.refresh_rate = 1.0  # Default refresh rate\n\nstate = AppState()\n\n# WebSocket connection manager\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n\n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n\n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n\n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            try:\n                await connection.send_text(message)\n            except WebSocketDisconnect:\n                # Will be removed on next iteration\n                pass\n\nmanager = ConnectionManager()\n\n# Root page\n@app.get(\"/\", response_class=HTMLResponse)\nasync def get_index(request: Request):\n    # Get current tasks\n    if state.repo_manager:\n        tasks = await state.repo_manager.fetch_clone_tasks()\n\n        # Count by status\n        queued = sum(1 for task in tasks.values() if task.status.status_type == \"queued\")\n        active = sum(1 for task in tasks.values() if task.status.status_type == \"cloning\")\n        completed = sum(1 for task in tasks.values() if task.status.status_type == \"completed\")\n        failed = sum(1 for task in tasks.values() if task.status.status_type == \"failed\")\n    else:\n        tasks = {}\n        queued, active, completed, failed = 0, 0, 0, 0\n\n    return templates.TemplateResponse(\"index.html\", {\n        \"request\": request,\n        \"tasks\": tasks,\n        \"queued\": queued,\n        \"active\": active,\n        \"completed\": completed,\n        \"failed\": failed\n    })\n\n# WebSocket endpoint\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await manager.connect(websocket)\n    try:\n        while True:\n            # Just keep the connection alive, we'll broadcast updates\n            await websocket.receive_text()\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n\n# Monitor task that periodically updates all clients\nasync def clone_monitor():\n    previous_tasks = {}\n\n    while True:\n        if state.repo_manager:\n            tasks = await state.repo_manager.fetch_clone_tasks()\n\n            # Check if tasks have changed\n            if tasks != previous_tasks:\n                # Count by status\n                queued = sum(1 for task in tasks.values() if task.status.status_type == \"queued\")\n                active = sum(1 for task in tasks.values() if task.status.status_type == \"cloning\")\n                completed = sum(1 for task in tasks.values() if task.status.status_type == \"completed\")\n                failed = sum(1 for task in tasks.values() if task.status.status_type == \"failed\")\n\n                # Create update message\n                message = {\n                    \"tasks\": tasks,\n                    \"summary\": {\n                        \"queued\": queued,\n                        \"active\": active,\n                        \"completed\": completed,\n                        \"failed\": failed\n                    }\n                }\n\n                # Broadcast to all clients\n                import json\n                await manager.broadcast(json.dumps(message, default=lambda o: o.__dict__))\n\n                # Update previous tasks\n                previous_tasks = tasks\n\n            # Check if we're done\n            if state.clone_future and state.clone_future.done():\n                # Get final status once more\n                tasks = await state.repo_manager.fetch_clone_tasks()\n                message = {\n                    \"tasks\": tasks,\n                    \"summary\": {\n                        \"queued\": 0,\n                        \"active\": 0,\n                        \"completed\": sum(1 for task in tasks.values() if task.status.status_type == \"completed\"),\n                        \"failed\": sum(1 for task in tasks.values() if task.status.status_type == \"failed\")\n                    },\n                    \"complete\": True\n                }\n                import json\n                await manager.broadcast(json.dumps(message, default=lambda o: o.__dict__))\n\n        # Wait before checking again\n        await asyncio.sleep(state.refresh_rate)\n\n# API to start cloning\n@app.post(\"/clone\")\nasync def start_clone(repos: List[str], username: Optional[str] = \"\", token: Optional[str] = \"\"):\n    \"\"\"Start cloning the specified repositories.\"\"\"\n    if state.clone_future and not state.clone_future.done():\n        return {\"status\": \"error\", \"message\": \"Clone operation already in progress\"}\n\n    # Create repo manager\n    state.repo_manager = RepoManager(\n        urls=repos,\n        github_username=username,\n        github_token=token\n    )\n\n    # Start cloning\n    state.clone_future = state.repo_manager.clone_all()\n\n    # Start monitor if not already running\n    if state.monitor_task is None or state.monitor_task.done():\n        state.monitor_task = asyncio.create_task(clone_monitor())\n\n    return {\"status\": \"success\", \"message\": f\"Started cloning {len(repos)} repositories\"}\n\n# API to get clone status\n@app.get(\"/status\")\nasync def get_status():\n    \"\"\"Get the current status of all clone operations.\"\"\"\n    if not state.repo_manager:\n        return {\"status\": \"error\", \"message\": \"No clone operation in progress\"}\n\n    tasks = await state.repo_manager.fetch_clone_tasks()\n\n    # Count by status\n    queued = sum(1 for task in tasks.values() if task.status.status_type == \"queued\")\n    active = sum(1 for task in tasks.values() if task.status.status_type == \"cloning\")\n    completed = sum(1 for task in tasks.values() if task.status.status_type == \"completed\")\n    failed = sum(1 for task in tasks.values() if task.status.status_type == \"failed\")\n\n    return {\n        \"status\": \"success\",\n        \"summary\": {\n            \"total\": len(tasks),\n            \"queued\": queued,\n            \"active\": active,\n            \"completed\": completed,\n            \"failed\": failed\n        },\n        \"tasks\": tasks\n    }\n\n# Set refresh rate\n@app.post(\"/refresh-rate\")\nasync def set_refresh_rate(rate: float):\n    \"\"\"Set the refresh rate for status updates (in seconds).\"\"\"\n    if rate &lt; 0.1:\n        return {\"status\": \"error\", \"message\": \"Refresh rate must be at least 0.1 seconds\"}\n\n    state.refresh_rate = rate\n    return {\"status\": \"success\", \"message\": f\"Refresh rate set to {rate} seconds\"}\n\n# Cleanup\n@app.post(\"/cleanup\")\nasync def cleanup():\n    \"\"\"Clean up clone directories.\"\"\"\n    if not state.repo_manager:\n        return {\"status\": \"error\", \"message\": \"No clone operation has been started\"}\n\n    cleanup_results = state.repo_manager.cleanup()\n    return {\"status\": \"success\", \"results\": cleanup_results}\n\n# Main function to start the server\ndef main():\n    parser = argparse.ArgumentParser(description=\"gitbench Web Monitor\")\n    parser.add_argument(\"--host\", default=\"127.0.0.1\", help=\"Host address to bind to\")\n    parser.add_argument(\"--port\", type=int, default=8000, help=\"Port to bind to\")\n    parser.add_argument(\"--reload\", action=\"store_true\", help=\"Enable auto-reload for development\")\n\n    # Additional arguments for automatic cloning\n    parser.add_argument(\"--repos\", nargs=\"+\", help=\"Repositories to clone automatically on startup\")\n    parser.add_argument(\"--github-username\", help=\"GitHub username for authentication\")\n    parser.add_argument(\"--github-token\", help=\"GitHub token for authentication\")\n\n    args = parser.parse_args()\n\n    # If repos are provided, start cloning automatically\n    if args.repos:\n        @app.on_event(\"startup\")\n        async def startup_event():\n            await start_clone(\n                repos=args.repos,\n                username=args.github_username or \"\",\n                token=args.github_token or \"\"\n            )\n\n    # Start server\n    uvicorn.run(\n        \"web_monitor:app\",\n        host=args.host,\n        port=args.port,\n        reload=args.reload\n    )\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/web-monitor/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<p>This example demonstrates several key features of gitbench combined with web technologies:</p> <ol> <li>Web Dashboard: Creating a real-time web interface for clone monitoring</li> <li>WebSockets: Using WebSockets for live updates without page refreshing</li> <li>RESTful API: Providing HTTP endpoints for controlling clone operations</li> <li>FastAPI Integration: Combining gitbench with the FastAPI web framework</li> <li>Automatic Status Updates: Broadcasting clone status changes to connected clients</li> <li>Interactive UI: Visual representation of clone progress and status</li> </ol>"},{"location":"examples/web-monitor/#web-monitor-architecture","title":"Web Monitor Architecture","text":"<p>The web monitor application consists of several components:</p> <ol> <li>FastAPI Server: Provides the web interface and API endpoints</li> <li>WebSocket Server: Handles real-time communication with web clients</li> <li>gitbench Backend: Manages repository cloning and monitoring</li> <li>HTML/CSS Frontend: Provides a user-friendly interface</li> <li>JavaScript Client: Updates the UI in real-time</li> </ol>"},{"location":"examples/web-monitor/#running-the-example","title":"Running the Example","text":"<p>To run this example:</p> <ol> <li> <p>Install gitbench with web dependencies:    <pre><code>pip install \"gitbench[web]\"\n</code></pre></p> </li> <li> <p>Save the example code to <code>web_monitor.py</code></p> </li> <li> <p>Run the server:    <pre><code>python web_monitor.py\n</code></pre></p> </li> <li> <p>Or run with automatic clone startup:    <pre><code>python web_monitor.py --repos https://github.com/octocat/Hello-World.git\n</code></pre></p> </li> <li> <p>Open a web browser and navigate to http://localhost:8000</p> </li> </ol>"},{"location":"examples/web-monitor/#api-endpoints","title":"API Endpoints","text":"<p>The web monitor provides several API endpoints:</p>"},{"location":"examples/web-monitor/#post-clone","title":"<code>POST /clone</code>","text":"<p>Start cloning repositories.</p> <p>Parameters: - <code>repos</code>: List of repository URLs to clone - <code>username</code> (optional): GitHub username for authentication - <code>token</code> (optional): GitHub token for authentication</p> <p>Example: <pre><code>curl -X POST \"http://localhost:8000/clone\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"repos\": [\"https://github.com/octocat/Hello-World.git\"], \"username\": \"\", \"token\": \"\"}'\n</code></pre></p>"},{"location":"examples/web-monitor/#get-status","title":"<code>GET /status</code>","text":"<p>Get the current status of clone operations.</p> <p>Example: <pre><code>curl \"http://localhost:8000/status\"\n</code></pre></p>"},{"location":"examples/web-monitor/#post-refresh-rate","title":"<code>POST /refresh-rate</code>","text":"<p>Set the refresh rate for status updates.</p> <p>Parameters: - <code>rate</code>: Refresh rate in seconds (minimum 0.1)</p> <p>Example: <pre><code>curl -X POST \"http://localhost:8000/refresh-rate\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"rate\": 2.0}'\n</code></pre></p>"},{"location":"examples/web-monitor/#post-cleanup","title":"<code>POST /cleanup</code>","text":"<p>Clean up clone directories.</p> <p>Example: <pre><code>curl -X POST \"http://localhost:8000/cleanup\"\n</code></pre></p>"},{"location":"examples/web-monitor/#websocket-communication","title":"WebSocket Communication","text":"<p>The web interface uses WebSockets for real-time updates. The WebSocket endpoint is <code>/ws</code> and provides JSON-formatted status updates:</p> <pre><code>const ws = new WebSocket(`ws://${window.location.host}/ws`);\n\nws.onmessage = function(event) {\n    const data = JSON.parse(event.data);\n    // Update UI with data\n};\n</code></pre>"},{"location":"examples/web-monitor/#ui-features","title":"UI Features","text":"<p>The web interface includes several UI features:</p> <ol> <li>Summary Dashboard: Shows counts of repositories by status</li> <li>Repository Cards: Individual cards for each repository</li> <li>Progress Bars: Visual representation of clone progress</li> <li>Status Indicators: Color-coded status indicators</li> <li>Error Display: Detailed error information for failed clones</li> <li>Real-time Updates: Live updates without page refreshing</li> </ol>"},{"location":"examples/web-monitor/#extending-the-example","title":"Extending the Example","text":"<p>This example can be extended in several ways:</p> <ol> <li>Authentication: Add user authentication for secure access</li> <li>Repository Management: Add UI for adding/removing repositories</li> <li>Advanced Monitoring: Add more detailed monitoring information</li> <li>Git Operations: Add interfaces for other Git operations</li> <li>Database Integration: Store historical clone information</li> <li>Notifications: Add email or webhook notifications for completed clones</li> </ol>"},{"location":"examples/web-monitor/#related-examples","title":"Related Examples","text":"<ul> <li>Clone Monitoring: Command-line monitoring of clone operations</li> <li>GitHub Client: Working with the GitHub API client</li> </ul>"},{"location":"providers/","title":"Git Provider API Clients","text":"<p>gitbench includes API clients for various Git hosting providers that allow you to interact with repositories, users, and other provider-specific information.</p>"},{"location":"providers/#available-providers","title":"Available Providers","text":"<p>The following providers are currently implemented:</p> <ul> <li>GitHub: Complete API client for GitHub with support for repositories, users, branches, and more.</li> </ul> <p>Coming soon: - GitLab: API client for GitLab (planned for v0.4.0) - BitBucket: API client for BitBucket (planned for v0.5.0)</p>"},{"location":"providers/#key-features","title":"Key Features","text":"<ul> <li>Data Models: Type-safe dataclasses for all provider data</li> <li>Dual Implementation: Both Rust and Python implementations</li> <li>Token Management: Built-in token rotation and rate limit handling </li> <li>Error Handling: Comprehensive error hierarchy for all providers</li> <li>Async Support: Full async/await support for concurrent operations</li> <li>Pandas Integration: Easy conversion to pandas DataFrames</li> </ul>"},{"location":"providers/#common-features","title":"Common Features","text":"<p>All provider clients share a common interface through the <code>GitProviderClient</code> base class, making it easy to work with different providers using the same code patterns.</p> <p>Common functionality includes:</p> <ul> <li>Repository information retrieval</li> <li>User data access</li> <li>Branch and contributor details</li> <li>Rate limit handling</li> </ul>"},{"location":"providers/#basic-usage","title":"Basic Usage","text":"<pre><code>import asyncio\nfrom gitbench import GitHubClient\n\nasync def main():\n    # Initialize the client with your token\n    # Will automatically use Rust implementation if available\n    github = GitHubClient(token=\"your-github-token\")\n\n    # Fetch repositories for a user\n    repos = await github.fetch_repositories(\"octocat\")\n\n    # Get user information (returns UserInfo dataclass)\n    user = await github.fetch_user_info()\n\n    # Check rate limits (returns RateLimitInfo dataclass)\n    rate_limit = await github.get_rate_limit()\n\n    # Work with typed dataclass objects\n    print(f\"Found {len(repos)} repositories\")\n    print(f\"Authenticated as: {user.login} ({user.name})\")\n    print(f\"API calls remaining: {rate_limit.remaining}/{rate_limit.limit}\")\n\n    # Explore repository details\n    for repo in repos[:3]:  # First 3 repos\n        print(f\"\\nRepository: {repo.full_name}\")\n        print(f\"  Description: {repo.description}\")\n        print(f\"  Language: {repo.language}\")\n        print(f\"  Stars: {repo.stargazers_count}\")\n        print(f\"  Forks: {repo.forks_count}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"providers/#token-management","title":"Token Management","text":"<p>gitbench includes a built-in <code>TokenManager</code> for handling rate limits and authentication across multiple tokens:</p> <pre><code>from gitbench import GitHubClient\nfrom gitbench.providers import TokenManager, ProviderType\n\n# Create a token manager\ntoken_manager = TokenManager()\ntoken_manager.add_token(\"token1\", ProviderType.GITHUB)\ntoken_manager.add_token(\"token2\", ProviderType.GITHUB)\n\n# Create a client with the token manager\ngithub = GitHubClient(\n    token=\"token1\",\n    token_manager=token_manager  # Auto-rotation of tokens\n)\n\n# The client will automatically use the next available token\n# when rate limits are hit\nrepos = await github.fetch_repositories(\"octocat\")\n</code></pre> <p>See the Token Management guide for more details.</p>"},{"location":"providers/#data-analysis-with-pandas","title":"Data Analysis with Pandas","text":"<p>All provider clients support converting their responses to pandas DataFrames for data analysis:</p> <pre><code># Option 1: Use the utility function\nfrom gitbench import to_dataframe\nrepos = await github.fetch_repositories(\"octocat\")\ndf = to_dataframe(repos)\n\n# Option 2: Use the client method\nrepos = await github.fetch_repositories(\"octocat\")\ndf = await github.to_pandas(repos)\n\n# Analyze the data\npopular_repos = df.sort_values(\"stargazers_count\", ascending=False)\nlanguages = df[\"language\"].value_counts()\n\n# Print the top 5 most popular repositories\nprint(popular_repos[[\"name\", \"stargazers_count\"]].head(5))\n</code></pre>"},{"location":"providers/#force-python-implementation","title":"Force Python Implementation","text":"<p>You can force gitbench to use the pure Python implementation if needed:</p> <pre><code># Force Python implementation\ngithub = GitHubClient(\n    token=\"your-github-token\",\n    use_python_impl=True  # Force Python implementation\n)\n</code></pre> <p>See the Implementation guide for more details.</p>"},{"location":"providers/github/","title":"GitHub API Client","text":"<p>The gitbench GitHub API client provides a convenient interface to interact with the GitHub API. This client allows you to fetch repository information, user data, and other GitHub-specific resources.</p>"},{"location":"providers/github/#installation","title":"Installation","text":"<p>The GitHub client is included with gitbench. No additional installation is required.</p> <pre><code>from gitbench import GitHubClient\n</code></pre>"},{"location":"providers/github/#authentication","title":"Authentication","text":"<p>Initialize the client with your GitHub personal access token:</p> <pre><code>github = GitHubClient(token=\"your-github-token\")\n</code></pre> <p>You can create a token on GitHub at https://github.com/settings/tokens.</p> <p>For GitHub Enterprise, you can specify a custom base URL:</p> <pre><code>github = GitHubClient(\n    token=\"your-github-token\",\n    base_url=\"https://github.your-company.com/api/v3\"\n)\n</code></pre>"},{"location":"providers/github/#basic-usage","title":"Basic Usage","text":""},{"location":"providers/github/#fetch-repositories","title":"Fetch Repositories","text":"<p>Retrieve repositories for a user or organization:</p> <pre><code># Get repositories for a user (returns a List[RepoInfo])\nrepos = await github.fetch_repositories(\"octocat\")\n\n# Print repository names using dataclass attributes\nfor repo in repos:\n    print(f\"{repo.full_name} - {repo.description}\")\n    print(f\"  Stars: {repo.stargazers_count}, Language: {repo.language}\")\n</code></pre>"},{"location":"providers/github/#user-information","title":"User Information","text":"<p>Get information about the authenticated user:</p> <pre><code># Returns UserInfo dataclass\nuser = await github.fetch_user_info()\nprint(f\"Authenticated as: {user.login}\")\nprint(f\"Name: {user.name}\")\nprint(f\"Email: {user.email}\")\nprint(f\"Avatar URL: {user.avatar_url}\")\n</code></pre>"},{"location":"providers/github/#repository-details","title":"Repository Details","text":"<p>Fetch detailed information about a specific repository:</p> <pre><code># Returns RepoDetails dataclass\nrepo = await github.fetch_repository_details(\"octocat\", \"hello-world\")\nprint(f\"Description: {repo.description}\")\nprint(f\"Topics: {', '.join(repo.topics)}\")\nprint(f\"License: {repo.license}\")\nprint(f\"Created: {repo.created_at}\")\nprint(f\"Updated: {repo.updated_at}\")\nprint(f\"Has Wiki: {repo.has_wiki}\")\n</code></pre>"},{"location":"providers/github/#contributors-and-branches","title":"Contributors and Branches","text":"<p>Get contributors for a repository:</p> <pre><code># Returns List[ContributorInfo]\ncontributors = await github.fetch_contributors(\"octocat\", \"hello-world\")\nfor contributor in contributors:\n    print(f\"{contributor.login} - {contributor.contributions} contributions\")\n    print(f\"  User ID: {contributor.id}\")\n</code></pre> <p>Get branches for a repository:</p> <pre><code># Returns List[BranchInfo]\nbranches = await github.fetch_branches(\"octocat\", \"hello-world\")\nfor branch in branches:\n    protected = \"Protected\" if branch.protected else \"Not protected\"\n    print(f\"{branch.name} - {protected}\")\n    print(f\"  Commit SHA: {branch.commit_sha}\")\n</code></pre>"},{"location":"providers/github/#rate-limits","title":"Rate Limits","text":"<p>Check your current rate limit status:</p> <pre><code># Returns RateLimitInfo dataclass\nrate_limit = await github.get_rate_limit()\nprint(f\"API calls remaining: {rate_limit.remaining}/{rate_limit.limit}\")\nprint(f\"Reset time: {rate_limit.reset_time}\")\nprint(f\"Used: {rate_limit.used}\")\n</code></pre>"},{"location":"providers/github/#implementation-selection","title":"Implementation Selection","text":"<p>You can choose between the Rust and Python implementations:</p> <pre><code># Default: Use Rust implementation if available, fall back to Python\ngithub = GitHubClient(token=\"your-token\")\n\n# Force Python implementation\ngithub_py = GitHubClient(\n    token=\"your-token\",\n    use_python_impl=True\n)\n\n# Check which implementation is being used\nif hasattr(github, \"_use_rust\"):\n    print(f\"Using Rust implementation: {github._use_rust}\")\n</code></pre>"},{"location":"providers/github/#error-handling","title":"Error Handling","text":"<p>The GitHub client includes a comprehensive error hierarchy:</p> <pre><code>from gitbench.providers.base import ProviderError, AuthError, RateLimitError\n\ntry:\n    repos = await github.fetch_repositories(\"octocat\")\nexcept AuthError as e:\n    print(f\"Authentication error: {e}\")\n    print(f\"Provider type: {e.provider_type}\")  # Will be ProviderType.GITHUB\nexcept RateLimitError as e:\n    print(f\"Rate limit exceeded. Resets at: {e.reset_time}\")\n    print(f\"Provider type: {e.provider_type}\")  # Will be ProviderType.GITHUB\nexcept ProviderError as e:\n    print(f\"Provider error: {e}\")\n    print(f\"Provider type: {e.provider_type}\")  # Will be ProviderType.GITHUB\n</code></pre> <p>You can also use provider-specific error classes:</p> <pre><code>from gitbench.providers.github import GitHubError\n\ntry:\n    repos = await github.fetch_repositories(\"octocat\")\nexcept GitHubError as e:\n    print(f\"GitHub error: {e}\")\n</code></pre> <p>The error hierarchy is as follows:</p> <pre><code>Exception\n\u2514\u2500\u2500 ProviderError (base.py)\n    \u251c\u2500\u2500 AuthError (base.py)\n    \u251c\u2500\u2500 RateLimitError (base.py)\n    \u2514\u2500\u2500 GitHubError (github.py)\n</code></pre>"},{"location":"providers/github/#data-analysis-with-pandas","title":"Data Analysis with Pandas","text":"<p>Convert API response data to pandas DataFrames for analysis:</p> <pre><code># Method 1: Using utility function (recommended)\nfrom gitbench import to_dataframe\n\nrepos = await github.fetch_repositories(\"octocat\")\ndf = to_dataframe(repos)\n\n# Method 2: Using client method\nrepos = await github.fetch_repositories(\"octocat\")\ndf = await github.to_pandas(repos)\n\n# Analyze the data\nprint(f\"Most popular repositories (by stars):\")\npopular_repos = df.sort_values(\"stargazers_count\", ascending=False)\nprint(popular_repos[[\"name\", \"stargazers_count\", \"forks_count\"]].head())\n\n# Language distribution\nprint(\"\\nLanguage distribution:\")\nprint(df[\"language\"].value_counts())\n\n# Filter by attributes\npython_repos = df[df[\"language\"] == \"Python\"]\nprint(f\"\\nPython repositories: {len(python_repos)}\")\n\n# Advanced queries\nactive_repos = df[(df[\"updated_at\"] &gt; \"2023-01-01\") &amp; (df[\"fork\"] == False)]\nprint(f\"\\nActive non-fork repos since 2023: {len(active_repos)}\")\n</code></pre>"},{"location":"providers/github/#working-with-contributors","title":"Working with Contributors","text":"<pre><code>contributors = await github.fetch_contributors(\"octocat\", \"hello-world\")\ncontributors_df = to_dataframe(contributors)\n\n# Find top contributors\ntop_contributors = contributors_df.sort_values(\"contributions\", ascending=False)\nprint(top_contributors[[\"login\", \"contributions\"]].head(10))\n</code></pre>"},{"location":"providers/github/#customizing-dataframe-conversion","title":"Customizing DataFrame Conversion","text":"<p>You can customize the DataFrame conversion by accessing the raw data:</p> <pre><code>repos = await github.fetch_repositories(\"octocat\")\n\n# Custom conversion with selected fields\nimport pandas as pd\ncustom_data = [\n    {\n        \"repo_name\": repo.name,\n        \"stars\": repo.stargazers_count or 0,\n        \"is_popular\": (repo.stargazers_count or 0) &gt; 100,\n        \"lang\": repo.language or \"Unknown\"\n    }\n    for repo in repos\n]\ncustom_df = pd.DataFrame(custom_data)\n</code></pre>"},{"location":"providers/github/#pagination","title":"Pagination","text":"<p>The GitHub client automatically handles pagination. You don't need to worry about pagination limits as the client will fetch all available results.</p>"},{"location":"providers/implementation/","title":"Dual Implementation Architecture","text":"<p>gitbench supports both Rust-based and pure Python implementations for its Git provider APIs. This architecture provides performance benefits when the Rust components are available, with a fallback to a pure Python implementation for maximum compatibility.</p>"},{"location":"providers/implementation/#architecture-overview","title":"Architecture Overview","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            Python Interface           \u2502\n\u2502                                       \u2502\n\u2502         GitProviderClient (ABC)       \u2502\n\u2502                  \u2502                    \u2502\n\u2502                  \u25bc                    \u2502\n\u2502          Specific Providers           \u2502\n\u2502     (GitHubClient, GitLabClient)      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                  \u2502\n      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502                       \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Rust     \u2502         \u2502    Python     \u2502\n\u2502 Backend   \u2502         \u2502   Backend     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"providers/implementation/#implementation-detection","title":"Implementation Detection","text":"<p>When you create a provider client (like <code>GitHubClient</code>), gitbench automatically detects if the Rust implementation is available:</p> <pre><code>from gitbench import GitHubClient\n\n# The client will use Rust implementation if available,\n# otherwise it will fall back to Python\nclient = GitHubClient(token=\"your-token\")\n</code></pre>"},{"location":"providers/implementation/#forcing-python-implementation","title":"Forcing Python Implementation","text":"<p>You can force gitbench to use the Python implementation even when Rust is available:</p> <pre><code># Force Python implementation\nclient = GitHubClient(\n    token=\"your-token\",\n    use_python_impl=True\n)\n</code></pre> <p>This can be useful for: - Debugging - Ensuring consistent behavior across environments - When you need features only available in the Python implementation</p>"},{"location":"providers/implementation/#checking-implementation-status","title":"Checking Implementation Status","text":"<p>You can check which implementation is being used:</p> <pre><code>from gitbench import GitHubClient\n\nclient = GitHubClient(token=\"your-token\")\n\n# Check if Rust implementation is available\nprint(f\"Rust available: {client._use_rust}\")\n</code></pre>"},{"location":"providers/implementation/#implementation-differences","title":"Implementation Differences","text":"<p>Both implementations provide the same interface and functionality, but there are some differences:</p>"},{"location":"providers/implementation/#performance","title":"Performance","text":"<p>The Rust implementation typically offers: - Faster request processing - More efficient memory usage - Better handling of concurrent requests</p>"},{"location":"providers/implementation/#features","title":"Features","text":"<p>The Python implementation may offer: - More granular control over HTTP requests - Easier debugging and customization - Additional helper methods in some cases</p>"},{"location":"providers/implementation/#error-handling","title":"Error Handling","text":"<p>Both implementations use the same error types, but error messages may differ slightly. The Python implementation provides more detailed error messages in some cases, while the Rust implementation typically provides more precise error codes.</p>"},{"location":"providers/implementation/#switching-at-runtime","title":"Switching at Runtime","text":"<p>You cannot switch implementations on an existing client instance. If you need to switch, create a new client:</p> <pre><code># Start with Rust implementation\nrust_client = GitHubClient(token=\"your-token\")\n\n# Later, create a Python implementation if needed\npython_client = GitHubClient(token=\"your-token\", use_python_impl=True)\n</code></pre>"},{"location":"providers/implementation/#token-management","title":"Token Management","text":"<p>Both implementations support the TokenManager for handling multiple tokens and rate limits:</p> <pre><code>from gitbench import GitHubClient\nfrom gitbench.providers import TokenManager\n\n# Create a token manager\ntoken_manager = TokenManager()\ntoken_manager.add_token(\"token1\", \"github\")\ntoken_manager.add_token(\"token2\", \"github\")\n\n# Use with Rust or Python implementation\nclient = GitHubClient(\n    token=\"token1\",\n    token_manager=token_manager\n)\n</code></pre>"},{"location":"providers/implementation/#implementation-details","title":"Implementation Details","text":""},{"location":"providers/implementation/#rust-implementation","title":"Rust Implementation","text":"<p>The Rust implementation: - Uses the <code>reqwest</code> crate for HTTP requests - Implements efficient serialization with <code>serde</code> - Uses Tokio for async runtime - Leverages Rust's memory safety and performance optimizations</p>"},{"location":"providers/implementation/#python-implementation","title":"Python Implementation","text":"<p>The Python implementation: - Uses <code>httpx</code> for async HTTP requests - Provides detailed error messages and debugging - Has no native dependencies besides Python's standard library - Provides fully typed interfaces with dataclasses</p>"},{"location":"providers/implementation/#future-compatibility","title":"Future Compatibility","text":"<p>As gitbench evolves: - Both implementations will maintain API compatibility - New features will be added to both implementations when possible - The Rust implementation will continue to focus on performance - The Python implementation will focus on flexibility and integration</p>"},{"location":"providers/models/","title":"Provider Data Models","text":"<p>gitbench uses standardized data models across all Git provider APIs. These models provide consistent data structures regardless of which provider (GitHub, GitLab, BitBucket) you are working with.</p>"},{"location":"providers/models/#core-data-models","title":"Core Data Models","text":"<p>All data models are implemented as Python dataclasses, providing type hints, autocompletion, and better IDE integration.</p>"},{"location":"providers/models/#repository-information","title":"Repository Information","text":"<pre><code>@dataclass\nclass RepoInfo:\n    \"\"\"Common repository information structure.\"\"\"\n    name: str                     # Repository name\n    full_name: str                # Full name (owner/repo)\n    clone_url: str                # Git clone URL\n    description: Optional[str]    # Repository description\n    default_branch: str           # Default branch name\n    created_at: str               # Creation timestamp\n    updated_at: str               # Last update timestamp\n    language: Optional[str]       # Primary language\n    fork: bool                    # Whether it's a fork\n    forks_count: int              # Number of forks\n    stargazers_count: Optional[int] # Number of stars\n    provider_type: ProviderType   # Provider (GitHub, GitLab, etc.)\n    visibility: str               # Visibility (public/private)\n    owner: Dict[str, Any]         # Owner information\n    raw_data: Optional[Dict[str, Any]] = None  # Raw provider data\n</code></pre>"},{"location":"providers/models/#user-information","title":"User Information","text":"<pre><code>@dataclass\nclass UserInfo:\n    \"\"\"User information structure.\"\"\"\n    id: str                       # User ID\n    login: str                    # Username/login\n    name: Optional[str]           # Full name\n    email: Optional[str]          # Email address\n    avatar_url: Optional[str]     # Avatar URL\n    provider_type: ProviderType   # Provider (GitHub, GitLab, etc.)\n    raw_data: Optional[Dict[str, Any]] = None  # Raw provider data\n</code></pre>"},{"location":"providers/models/#rate-limit-information","title":"Rate Limit Information","text":"<pre><code>@dataclass\nclass RateLimitInfo:\n    \"\"\"Rate limit information structure.\"\"\"\n    limit: int                    # Total request limit\n    remaining: int                # Remaining requests\n    reset_time: int               # Reset timestamp\n    used: int                     # Used requests count\n    provider_type: ProviderType   # Provider (GitHub, GitLab, etc.)\n</code></pre>"},{"location":"providers/models/#detailed-repository-information","title":"Detailed Repository Information","text":"<pre><code>@dataclass\nclass RepoDetails(RepoInfo):\n    \"\"\"Detailed repository information structure.\"\"\"\n    topics: List[str]             # Repository topics/tags\n    license: Optional[str]        # License information\n    homepage: Optional[str]       # Homepage URL\n    has_wiki: bool                # Whether repo has wiki\n    has_issues: bool              # Whether repo has issues\n    has_projects: bool            # Whether repo has projects\n    archived: bool                # Whether repo is archived\n    pushed_at: Optional[str]      # Last push timestamp\n    size: int                     # Repository size\n</code></pre>"},{"location":"providers/models/#contributor-information","title":"Contributor Information","text":"<pre><code>@dataclass\nclass ContributorInfo:\n    \"\"\"Contributor information structure.\"\"\"\n    login: str                    # Username\n    id: str                       # User ID\n    avatar_url: Optional[str]     # Avatar URL\n    contributions: int            # Number of contributions\n    provider_type: ProviderType   # Provider (GitHub, GitLab, etc.)\n</code></pre>"},{"location":"providers/models/#branch-information","title":"Branch Information","text":"<pre><code>@dataclass\nclass BranchInfo:\n    \"\"\"Branch information structure.\"\"\"\n    name: str                     # Branch name\n    commit_sha: str               # Latest commit SHA\n    protected: bool               # Whether branch is protected\n    provider_type: ProviderType   # Provider (GitHub, GitLab, etc.)\n</code></pre>"},{"location":"providers/models/#working-with-models","title":"Working with Models","text":""},{"location":"providers/models/#direct-access","title":"Direct Access","text":"<p>Each model provides direct attribute access:</p> <pre><code># Get repositories for a user\nrepos = await github.fetch_repositories(\"octocat\")\n\n# Access model attributes directly\nfor repo in repos:\n    print(f\"Repository: {repo.full_name}\")\n    print(f\"Description: {repo.description}\")\n    print(f\"Stars: {repo.stargazers_count}\")\n</code></pre>"},{"location":"providers/models/#working-with-dates","title":"Working with Dates","text":"<p>Date fields like <code>created_at</code> and <code>updated_at</code> are stored as strings but have helper methods to convert them to datetime objects:</p> <pre><code># Get a repository\nrepo = repos[0]\n\n# Convert string dates to datetime objects\nif repo.created_at:\n    created_dt = repo.created_datetime()\n    print(f\"Created: {created_dt.strftime('%Y-%m-%d %H:%M:%S')}\")\n\n    # Note: The datetime objects are timezone-aware\n    # See the \"Working with Dates and Times\" guide for details\n    # on handling timezone-aware datetimes\n</code></pre> <p>For complete details on working with dates, see the Working with Dates and Times guide.</p>"},{"location":"providers/models/#conversion-to-pandas-dataframes","title":"Conversion to Pandas DataFrames","text":"<p>All models can be converted to pandas DataFrames for data analysis:</p> <pre><code># Import pandas converter\nfrom gitbench import to_dataframe\n\n# Get repositories for a user\nrepos = await github.fetch_repositories(\"octocat\")\n\n# Convert to DataFrame\ndf = to_dataframe(repos)\n\n# Analyze the data\ntop_repos = df.sort_values(\"stargazers_count\", ascending=False).head(10)\nlanguage_distribution = df[\"language\"].value_counts()\n</code></pre> <p>You can also use a client-specific method:</p> <pre><code>repos = await github.fetch_repositories(\"octocat\")\ndf = await github.to_pandas(repos)\n</code></pre>"},{"location":"providers/models/#raw-provider-data","title":"Raw Provider Data","text":"<p>Each model includes the original provider data for advanced use cases:</p> <pre><code>repo = await github.fetch_repository_details(\"octocat\", \"hello-world\")\n\n# Access standardized fields\nprint(repo.stargazers_count)\n\n# Access raw provider data for GitHub-specific fields\nif repo.raw_data and \"allow_forking\" in repo.raw_data:\n    print(f\"Allows forking: {repo.raw_data['allow_forking']}\")\n</code></pre>"},{"location":"providers/models/#error-handling","title":"Error Handling","text":"<p>When working with provider models, you may encounter provider-specific errors:</p> <pre><code>from gitbench.providers.base import ProviderError, AuthError, RateLimitError\n\ntry:\n    repos = await github.fetch_repositories(\"octocat\")\nexcept AuthError as e:\n    print(f\"Authentication error: {e}\")\nexcept RateLimitError as e:\n    print(f\"Rate limit exceeded. Resets at: {e.reset_time}\")\nexcept ProviderError as e:\n    print(f\"Provider error: {e}\")\n</code></pre>"},{"location":"providers/models/#provider-type-enumeration","title":"Provider Type Enumeration","text":"<p>The <code>ProviderType</code> enumeration is used to identify which provider a model belongs to:</p> <pre><code>from gitbench.providers import ProviderType\n\n# Check the provider type\nrepos = await github.fetch_repositories(\"octocat\")\nif repos[0].provider_type == ProviderType.GITHUB:\n    print(\"This is a GitHub repository\")\n</code></pre> <p>Available provider types: - <code>ProviderType.GITHUB</code> - <code>ProviderType.GITLAB</code> (coming soon) - <code>ProviderType.BITBUCKET</code> (coming soon)</p>"}]}